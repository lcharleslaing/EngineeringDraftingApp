{% extends 'base.html' %}
{% load process_filters %}
{% block title %}Edit: {{ process.name }}{% endblock %}
{% block extra_head %}
<meta name="viewport" content="width=device-width, initial-scale=1.0">
{% endblock %}
{% block extra_css %}
<style>
  .draggable-pill {
    cursor: grab;
    transition: all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    user-select: none;
  }
  .draggable-pill:active {
    cursor: grabbing;
  }
  .draggable-pill.dragging {
    transform: scale(0.99);
    opacity: 0.8 !important;
    transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  }
  .draggable-pill:hover {
    transform: translateY(-1px);
    box-shadow: 0 3px 12px rgba(0,0,0,0.1);
  }
  .drop-indicator {
    animation: pulse 1s infinite;
  }
  @keyframes pulse {
    0%, 100% { opacity: 0.6; }
    50% { opacity: 1; }
  }
  
  /* Compact Mode Styles */
  .step-compact {
    min-height: auto !important;
    padding: 0.5rem !important;
  }
  .step-compact .card-body {
    padding: 0.5rem !important;
  }
  .step-compact .step-title {
    font-size: 0.875rem;
    font-weight: 600;
    margin: 0;
    background: transparent !important;
    border: none !important;
    padding: 0.25rem 0.5rem !important;
    color: inherit !important;
  }
  .step-compact .step-content {
    display: none !important;
  }
  .step-compact .step-number-circle {
    width: 1.5rem !important;
    height: 1.5rem !important;
    font-size: 0.75rem !important;
  }
  .step-compact .step-buttons {
    display: none !important;
  }
  .step-compact .bullet-pills-container {
    display: none !important;
  }
  .step-compact .toggle-textarea,
  .step-compact .toggle-attachments,
  .step-compact .toggle-pdfs-step {
    display: none !important;
  }
  
  /* Textarea Auto-resize */
  .step-details {
    width: 100% !important;
    min-height: auto;
    resize: none;
    overflow: hidden;
    height: auto;
  }
  
  /* Drag handle styling */
  .drag {
    cursor: grab;
  }
  .drag:active {
    cursor: grabbing;
  }
  
  /* Step Navigation Sidebar */
  #step-nav {
    transition: all 0.3s ease;
    max-height: calc(100vh - 120px);
    overflow-y: auto;
    padding: 20px 0;
  }
  
  /* Mobile responsiveness */
  /* Compact side nav: hide titles on medium/smaller screens, keep circles */
  @media (max-width: 1400px) {
    .step-nav-title { display: none !important; }
    .step-nav-item { gap: 6px; padding: 2px 4px; }
  }

  @media (max-width: 768px) {
    #step-nav {
      left: 0.5rem; /* keep visible on small screens */
    }
    
    .sticky.top-0 {
      position: relative !important;
      z-index: 10;
    }
    
    .max-w-7xl {
      max-width: 100%;
      padding: 0 0.5rem;
    }
    
    .grid.grid-cols-12 {
      grid-template-columns: 1fr;
    }
    
    .col-span-12 {
      grid-column: span 1;
    }
    
    .flex.items-center.gap-3 {
      flex-direction: column;
      gap: 0.5rem;
      align-items: stretch;
    }
    
    .flex.items-center.gap-2 {
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    
    .ml-auto.flex.gap-2 {
      margin-left: 0;
      width: 100%;
      justify-content: space-between;
    }
    
    .btn {
      font-size: 0.75rem;
      padding: 0.25rem 0.5rem;
    }
    
    .step-card {
      margin-bottom: 1rem;
      padding-top: 1.75rem; /* space for number circle */
    }
    
    .card-body {
      padding: 0.75rem;
    }
    
    .step-title {
      font-size: 0.875rem;
      margin-bottom: 0.5rem;
    }
    
    .bullet-pills-container {
      margin: 0.5rem 0;
    }
    
    .draggable-pill {
      padding: 0.75rem;
      font-size: 0.875rem;
      width: 100%;
      min-height: 2.5rem;
    }
    
    .step-attachments {
      margin-top: 0.5rem;
    }
    
    .grid.grid-cols-2.md\\:grid-cols-3 {
      grid-template-columns: repeat(2, 1fr);
      gap: 0.25rem;
    }
    
    .text-sm {
      font-size: 0.75rem;
    }
    
    .text-xs {
      font-size: 0.625rem;
    }
    
    .modal-box {
      margin: 0.5rem;
      max-width: calc(100vw - 1rem);
    }
    
    .toast {
      font-size: 0.75rem;
      max-width: 90vw;
    }
    /* Move number circle to top-left on mobile */
    .step-card > .absolute.-top-3.left-1\/2 {
      left: 0.5rem;
      transform: translateX(0);
    }
    .step-number-circle {
      width: 1.5rem !important;
      height: 1.5rem !important;
      font-size: 0.75rem !important;
    }

    .step-title.input {
      width: 100%;
    }

    .input, .textarea, .select {
      width: 100%;
    }

    .btn.btn-sm {
      min-height: 2rem;
    }
  }
  
  @media (max-width: 480px) {
    .flex.items-center.gap-2 {
      flex-direction: column;
      align-items: stretch;
    }
    
    .ml-auto.flex.gap-2 {
      flex-direction: column;
      gap: 0.25rem;
    }
    
    .btn {
      width: 100%;
      justify-content: center;
    }
    
    .grid.grid-cols-2.md\\:grid-cols-3 {
      grid-template-columns: 1fr;
    }
    
    .draggable-pill {
      flex-direction: row;
      text-align: left;
      align-items: center;
    }
    
    .pill-number {
      margin-right: 0.5rem;
      margin-bottom: 0;
      flex-shrink: 0;
    }
    
    .pill-text {
      flex: 1;
      text-align: left;
    }
  }
  /* Line removed for cleaner look */
  .step-nav-circles {
    position: relative;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 0;
  }
  .step-nav-item {
    display: flex;
    align-items: center;
    gap: 12px;
    cursor: pointer;
    transition: all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    padding: 4px 8px;
    border-radius: 8px;
    margin-bottom: 0;
    position: relative;
  }
  .step-nav-item:hover {
    background: rgba(59, 130, 246, 0.1);
  }
  .step-nav-circle {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    background: #3b82f6;
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    border: 2px solid white;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    z-index: 10;
    position: relative;
    flex-shrink: 0;
  }
  .step-nav-title {
    color: #374151;
    font-size: 13px;
    font-weight: 500;
    line-height: 1.3;
    max-width: 200px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .step-nav-circle:hover {
    background: #1d4ed8;
    transform: scale(1.02);
    box-shadow: 0 3px 10px rgba(0,0,0,0.15);
  }
  .step-nav-circle.active {
    background: #10b981;
    box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.2);
    transform: scale(1.01);
  }
  
  /* Smooth transitions for step cards */
  .step-card {
    transition: all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  }
  .step-card:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 15px rgba(0,0,0,0.08);
  }
  
  /* Smooth transitions for buttons */
  .btn {
    transition: all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  }
  .btn:hover {
    transform: translateY(-0.5px);
  }
  
  /* Smooth transitions for form elements */
  .input, .textarea, .select {
    transition: all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  }
  .input:focus, .textarea:focus, .select:focus {
    transform: scale(1.005);
  }
</style>
{% endblock %}
{% block content %}
<div class="sticky top-0 z-0 bg-base-100/90 backdrop-blur border-b border-base-200 mb-6">
  <div class="max-w-7xl mx-auto px-1 sm:px-2 lg:px-4 py-3">
    <div class="flex items-center gap-3 mb-3">
      <input id="process-name" class="input input-bordered w-full" value="{{ process.name }}" placeholder="Process name" required />
      <select id="process-module" class="select select-bordered w-full max-w-xs">
        <option value="">No Module</option>
        {% for module in modules %}
          <option value="{{ module.id }}" {% if process.module and process.module.id == module.id %}selected{% endif %}>
            {{ module.name }}
          </option>
        {% endfor %}
        <option value="__new__">+ New Module…</option>
      </select>
      <button id="stats-btn" class="btn btn-info btn-sm" data-process-id="{{ process.id }}">Stats</button>
    </div>
    <div class="text-xs text-base-content/70 mb-2">
      <span class="badge badge-outline badge-sm">Created: {{ process.created_at|date:"M d, Y g:i A" }}</span>
      <span class="badge badge-outline badge-sm ml-2">Updated: {{ process.updated_at|date:"M d, Y g:i A" }}</span>
    </div>
    <div class="flex flex-col lg:flex-row items-start lg:items-center gap-2 lg:gap-2">
      <div class="flex flex-wrap gap-2">
        <label class="flex items-center gap-2">
          <input id="toggle-images" type="checkbox" class="toggle toggle-primary" />
          <span class="text-sm">Show Attachments</span>
        </label>
        <label class="flex items-center gap-2">
          <input id="toggle-summary" type="checkbox" class="toggle toggle-secondary" />
          <span class="text-sm">Show Summary</span>
        </label>
        <label class="flex items-center gap-2">
          <input id="toggle-analysis" type="checkbox" class="toggle toggle-accent" />
          <span class="text-sm">Show Analysis</span>
        </label>
        <label class="flex items-center gap-2">
          <input id="toggle-description" type="checkbox" class="toggle toggle-info" />
          <span class="text-sm">Show Description</span>
        </label>
        <label class="flex items-center gap-2">
          <input id="toggle-notes" type="checkbox" class="toggle toggle-warning" />
          <span class="text-sm">Show Notes</span>
        </label>
        <label class="flex items-center gap-2">
          <input id="toggle-pdfs" type="checkbox" class="toggle toggle-error" />
          <span class="text-sm">Show PDFs</span>
        </label>
      </div>
      <div class="flex flex-wrap gap-2 w-full lg:w-auto lg:ml-auto">
        <a class="btn btn-outline btn-sm" href="{% url 'process_creator:list' %}">Back</a>
        <a class="btn btn-outline btn-sm" href="{% url 'process_creator:print' process.id %}" target="_blank">Print</a>
        <button id="copy-btn" class="btn btn-primary btn-sm" data-copy-url="{% url 'process_creator:copy' process.id %}">Copy</button>
        <button id="pdf-btn" class="btn btn-secondary btn-sm" disabled title="PDF export temporarily disabled">Save PDF</button>
        <a id="word-btn" class="btn btn-accent btn-sm" href="{% url 'process_creator:word' process.id %}">Save Word</a>
      </div>
    </div>
  </div>
</div>

<div class="max-w-7xl mx-auto px-1 sm:px-2 lg:px-4">
  <div class="grid grid-cols-12 gap-6">
    <div class="col-span-12" id="summary-section">
      <div class="card bg-base-200 shadow-sm">
        <div class="card-body p-4">
          <div class="flex items-center justify-between mb-4">
            <h2 class="font-semibold text-lg">📝 Process Summary</h2>
            <button id="create-summary-btn" class="btn btn-primary btn-sm" data-process-id="{{ process.id }}">
              <i class="fas fa-robot mr-1"></i>Create Summary
            </button>
          </div>
          
          <div class="mb-4">
            <label class="label">
              <span class="label-text font-medium">Summary Instructions</span>
            </label>
            <textarea id="summary-instructions" class="textarea textarea-bordered w-full min-h-20 auto-resize" placeholder="Instructions for AI summary generation">{{ process.summary_instructions }}</textarea>
          </div>
          
          <div>
            <label class="label">
              <span class="label-text font-medium">Summary</span>
            </label>
            <textarea id="process-summary" class="textarea textarea-bordered w-full min-h-24 auto-resize" placeholder="AI-generated summary of the process">{{ process.summary }}</textarea>
          </div>
        </div>
      </div>
    </div>

    <div class="col-span-12" id="description-section">
      <h2 class="font-semibold mb-2">Description</h2>
      <textarea id="process-description" class="textarea textarea-bordered w-full min-h-28 auto-resize" placeholder="Describe the process">{{ process.description }}</textarea>
    </div>

    <div class="col-span-12">
      <div class="flex items-center justify-between mb-2">
        <h2 class="font-semibold">Steps</h2>
        <div class="flex flex-col sm:flex-row gap-2 w-full sm:w-auto">
          <button id="add-step" class="btn btn-primary btn-sm flex-1 sm:flex-none">Add step</button>
          <button id="compact-mode-toggle" class="btn btn-outline btn-sm flex-1 sm:flex-none">
            <i class="fas fa-compress-alt mr-1"></i>Compact Mode
          </button>
        </div>
      </div>
      
      <!-- Step Navigation Sidebar -->
      <div id="step-nav" class="fixed left-4 top-1/2 transform -translate-y-1/2 z-30 hidden">
        <div class="step-nav-line"></div>
        <div class="step-nav-circles"></div>
      </div>
      
      <div id="steps" class="space-y-6">
        {% for step in process.steps.all %}
          <div class="card bg-base-200 shadow-sm relative step-card" data-id="{{ step.id }}">
            <!-- Step Number Circle -->
            <div class="absolute -top-3 left-1/2 transform -translate-x-1/2 z-20">
              <div class="w-8 h-8 rounded-full bg-blue-500 text-white flex items-center justify-center text-sm font-bold shadow-lg border-2 border-white step-number-circle">
                {{ step.order }}
              </div>
            </div>
            <div class="card-body p-4 pt-8">
              <div class="flex items-center gap-3 w-full">
                <span class="drag cursor-grab text-base-300 flex-shrink-0" title="Drag to reorder">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="currentColor"><path d="M10 4h4v2h-4V4zm0 14h4v2h-4v-2zM4 10h2v4H4v-4zm14 0h2v4h-2v-4z"/></svg>
                </span>
                <input class="step-title input input-sm input-bordered flex-1" value="{{ step.title }}" required />
                <div class="flex gap-1 step-buttons flex-shrink-0">
                  <button class="btn btn-sm" data-insert="up" title="Add before">+ Before</button>
                  <button class="btn btn-sm" data-insert="down" title="Add after">+ After</button>
                  <button class="btn btn-sm btn-error step-delete">Delete</button>
                </div>
              </div>
              <!-- Step Timestamps -->
              <div class="text-xs text-base-content/60 mb-2">
                <span class="badge badge-ghost badge-xs">Created: {{ step.created_at|date:"M d, Y g:i A" }}</span>
                <span class="badge badge-ghost badge-xs ml-1">Updated: {{ step.updated_at|date:"M d, Y g:i A" }}</span>
              </div>
              <!-- Bullet Pills Container -->
              <div class="bullet-pills-container mt-3 mb-2" id="pills-{{ step.id }}">
                <div class="text-sm opacity-70 mb-2">Bullet Points (drag to reorder)</div>
                <div class="pills-list grid grid-cols-2 md:grid-cols-3 gap-1 md:gap-2" id="pills-list-{{ step.id }}">
                  <!-- Pills will be dynamically added here -->
                </div>
              </div>
              <div class="step-content">
                <textarea class="step-details textarea textarea-bordered mt-3 auto-resize" placeholder="Details (use - for bullet points)" style="display: none;">{{ step.details }}</textarea>
              <!-- Links -->
              <div class="mt-3 step-attachments" id="attachments-{{ step.id }}" style="display: none;">
                <div class="text-sm opacity-70 mb-1">Links</div>
                <div class="flex flex-wrap gap-2" id="links-{{ step.id }}">
                  {% for link in step.links.all %}
                    <div class="relative group">
                      <a href="{{ link.url }}" target="_blank" class="btn btn-outline btn-sm" data-link-id="{{ link.id }}">{{ link.title }}</a>
                      <button class="btn btn-xs btn-error absolute -top-2 -right-2 opacity-0 group-hover:opacity-100 delete-link text-xs w-4 h-4 min-h-0 p-0 flex items-center justify-center" data-step="{{ step.id }}" data-id="{{ link.id }}">✕</button>
                    </div>
                  {% endfor %}
                </div>
              </div>
              <!-- PDFs / CAD Files -->
              <div class="mt-3 step-attachments" id="attachments-{{ step.id }}" style="display: none;">
                <div class="text-sm opacity-70 mb-1">Documents (paste or drop PDF / DWG / IDW)</div>
                <div class="grid grid-cols-2 md:grid-cols-3 gap-2" id="pdfs-{{ step.id }}">
                  {% for f in step.files.all %}
                    <div class="relative group">
                      <div class="rounded border w-full h-28 bg-base-300/30 flex items-center justify-center cursor-pointer pdf-thumb" data-url="{{ f.file.url }}" data-name="{{ f.file.name|basename }} ({{ f.uploaded_at|date:'mdy-HisA' }})" title="{{ f.file.name|basename }}">
                        <span class="text-xs">PDF</span>
                      </div>
                      <button class="btn btn-xs btn-error absolute top-1 right-1 opacity-0 group-hover:opacity-100 delete-pdf" data-step="{{ step.id }}" data-id="{{ f.id }}">✕</button>
                    </div>
                  {% endfor %}
                </div>
                <div class="mt-2 flex gap-2">
                  <input type="file" accept="application/pdf,.pdf,.dwg,.idw" class="hidden" data-upload-pdf-step="{{ step.id }}" />
                  <button type="button" class="btn btn-sm" data-open-pdf-upload="{{ step.id }}">Add Document</button>
                </div>
              </div>
              <div class="mt-3 img-section step-attachments" id="attachments-{{ step.id }}" style="display: none;">
                <div class="text-sm opacity-70 mb-1">Screenshots (paste or drop images)</div>
                <div class="grid grid-cols-2 md:grid-cols-3 gap-2" id="imgs-{{ step.id }}" data-step-id="{{ step.id }}">
                  {% for img in step.images.all %}
                    <div class="relative group draggable-img" data-img-id="{{ img.id }}" data-order="{{ img.order }}" data-substep-index="{{ img.substep_index|default_if_none:'' }}" draggable="true">
                      <img src="{{ img.image.url }}" class="rounded border object-cover w-full h-28" />
                      <button class="btn btn-xs btn-error absolute top-1 right-1 opacity-0 group-hover:opacity-100 delete-img" data-step="{{ step.id }}" data-id="{{ img.id }}">✕</button>
                      <!-- Image Number Circle -->
                      <div class="absolute -top-2 -left-2 w-6 h-6 rounded-full bg-secondary text-secondary-content flex items-center justify-center text-xs font-bold shadow-lg z-20 border border-base-100">
                        {{ img.order }}
                      </div>
                    </div>
                  {% endfor %}
                </div>
                <div class="mt-2 flex gap-2">
                  <button type="button" class="btn btn-sm" data-open-upload="{{ step.id }}">Add images</button>
                  <input type="file" accept="image/*" multiple class="hidden" data-upload-step="{{ step.id }}" />
                </div>
              </div>
              </div>
              <div class="mt-2 flex flex-col sm:flex-row gap-2">
                <button class="btn btn-sm btn-outline toggle-textarea flex-1 sm:flex-none" data-step="{{ step.id }}">
                  <span class="toggle-text">Edit Text</span>
                </button>
                <button class="btn btn-sm btn-outline toggle-attachments flex-1 sm:flex-none" data-step="{{ step.id }}">
                  <span class="toggle-text">Show Attachments</span>
                </button>
                <button class="btn btn-sm btn-outline clear-image-links flex-1 sm:flex-none" title="Clear Image Connections" data-step="{{ step.id }}">
                  <i class="fas fa-unlink mr-1"></i> Clear Image Connections
                </button>
                <button class="btn btn-sm btn-outline toggle-pdfs-step flex-1 sm:flex-none" data-step="{{ step.id }}">
                  <span class="toggle-text">Show PDFs</span>
                </button>
                <button class="btn btn-sm btn-outline focus-step flex-1 sm:flex-none" data-step="{{ step.id }}">
                  Focus This Only
                </button>
              </div>
            </div>
          </div>
        {% endfor %}
      </div>
    </div>

    <div class="col-span-12" id="notes-section">
      <h2 class="font-semibold mb-2">Notes</h2>
      <textarea id="process-notes" class="textarea textarea-bordered w-full min-h-40 auto-resize" placeholder="Any notes">{{ process.notes }}</textarea>
    </div>

    <div class="col-span-12" id="analysis-section">
      <div class="card bg-base-200 shadow-sm">
        <div class="card-body p-4">
          <div class="flex items-center justify-between mb-4">
            <h2 class="font-semibold text-lg">📊 Process Analysis</h2>
            <button id="analyze-btn" class="btn btn-accent btn-sm" data-process-id="{{ process.id }}">
              <i class="fas fa-brain mr-1"></i>Analyze Process
            </button>
          </div>
          
          <div class="mb-4">
            <label class="label">
              <span class="label-text font-medium">Analysis Instructions</span>
            </label>
            <textarea id="analysis-instructions" class="textarea textarea-bordered w-full min-h-32 auto-resize" placeholder="Instructions for AI analysis">{{ process.analysis_instructions }}</textarea>
          </div>
          
          <div>
            <label class="label">
              <span class="label-text font-medium">Analysis Results</span>
            </label>
            <textarea id="process-analysis" class="textarea textarea-bordered w-full min-h-40 auto-resize" placeholder="AI-generated analysis and improvement suggestions">{{ process.analysis }}</textarea>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Stats Modal -->
<dialog id="stats-modal" class="modal">
  <div class="modal-box w-11/12 max-w-2xl">
    <div class="flex items-center justify-between mb-6">
      <h3 class="font-bold text-2xl text-primary">📊 Process Statistics</h3>
      <button class="btn btn-sm btn-circle btn-ghost" onclick="document.getElementById('stats-modal').close()">✕</button>
    </div>
    <div id="stats-content" class="space-y-4">
      <!-- Stats will be loaded here -->
    </div>
  </div>
</dialog>

<!-- Image Viewer Modal (Full Screen) -->
<dialog id="image-modal" class="modal">
  <div class="modal-box w-screen h-screen max-w-none max-h-none p-0 bg-base-100 relative">
    <button class="btn btn-sm btn-circle btn-ghost absolute right-3 top-3 z-20" onclick="document.getElementById('image-modal').close()">✕</button>
    <div id="zoom-stage" class="w-full h-full overflow-hidden bg-base-100">
      <img id="modal-image" src="" alt="Full size image" class="select-none cursor-move will-change-transform" style="width:100%; height:100%; object-fit: contain; transform: translate(0px,0px) scale(1);" />
    </div>
  </div>
</dialog>

{% endblock %}

{% block extra_js %}
<!-- PDF.js for client-side PDF thumbnail rendering -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.3.136/pdf.min.js" integrity="sha512-0OqkJwYtX3WxbA1q3qkX6SC+h4Yl3fCk9t6Gxg8v8QKQ4M4w+0sXgK5g5QX7wAvm6sDg7fDc5e5M8i7w9Yj0PA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script>
if (window['pdfjsLib']) {
  pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.3.136/pdf.worker.min.js';
}
</script>
<script>
const processId = {{ process.id }};
const base = '/process-creator/' + processId + '/';

async function post(url, data){
  const form = new URLSearchParams();
  for(const [k,v] of Object.entries(data||{})) form.append(k,v);
  const res = await fetch(url, {method:'POST', headers:{'X-CSRFToken': getCookie('csrftoken')}, body:form});
  return res.json();
}

function getCookie(name){
  const value = `; ${document.cookie}`.split(`; ${name}=`).pop();
  return value ? value.split(';').shift() : '';
}

// Track if process has been updated since last AI interaction
let processUpdated = false;

// Autosave process fields
function debouncedSave(){
  clearTimeout(window._saveT); window._saveT = setTimeout(() => {
    post(base + 'update/', {
      description: document.getElementById('process-description').value,
      notes: document.getElementById('process-notes').value,
      summary: document.getElementById('process-summary').value,
      summary_instructions: document.getElementById('summary-instructions').value,
      analysis: document.getElementById('process-analysis').value,
      analysis_instructions: document.getElementById('analysis-instructions').value,
    }).then(() => {
      processUpdated = true;
    });
  }, 400);
}

document.getElementById('process-description').addEventListener('input', debouncedSave);
document.getElementById('process-notes').addEventListener('input', debouncedSave);
document.getElementById('process-summary').addEventListener('input', debouncedSave);
document.getElementById('summary-instructions').addEventListener('input', debouncedSave);
document.getElementById('process-analysis').addEventListener('input', debouncedSave);
document.getElementById('analysis-instructions').addEventListener('input', debouncedSave);

// Name change via simple submit to update endpoint
document.getElementById('process-name').addEventListener('change', async (e)=>{
  await fetch(base + 'update/', {method:'POST', headers:{'X-CSRFToken': getCookie('csrftoken')}, body:new URLSearchParams({name:e.target.value})});
});

// Module change via simple submit to update endpoint
document.getElementById('process-module').addEventListener('change', async (e)=>{
  if (e.target.value === '__new__') {
    openCreateModuleModal({ afterCreate: async (mod)=>{
      // set selected
      const sel = document.getElementById('process-module');
      const opt = document.createElement('option'); opt.value = mod.id; opt.textContent = mod.name;
      sel.insertBefore(opt, sel.querySelector('option[value="__new__"]'));
      sel.value = mod.id;
      await fetch(base + 'update/', {method:'POST', headers:{'X-CSRFToken': getCookie('csrftoken')}, body:new URLSearchParams({module:mod.id})});
      // Save module selection to localStorage
      try { localStorage.setItem('process_creator_selected_module', mod.id); } catch(e) {}
    }});
    // restore current while modal open
    e.target.value = '{{ process.module.id|default:"" }}';
    return;
  }
  await fetch(base + 'update/', {method:'POST', headers:{'X-CSRFToken': getCookie('csrftoken')}, body:new URLSearchParams({module:e.target.value})});
  // Save module selection to localStorage
  try { localStorage.setItem('process_creator_selected_module', e.target.value); } catch(e) {}
});

// Add step
document.getElementById('add-step').addEventListener('click', async ()=>{
  const data = await post(base + 'steps/add/', {title:'New Step'});
  
  // Set a flag to scroll to new step after reload
  sessionStorage.setItem('scrollToNewStep', 'true');
  
  location.reload();
});

// Update step fields
document.querySelectorAll('#steps .card').forEach(card=>{
  const id = card.dataset.id;
  card.querySelector('.step-title').addEventListener('change', e=>{
    post(base + 'steps/' + id + '/update/', {title:e.target.value});
    // Update navigation title immediately
    updateNavigationTitle(id, e.target.value);
  });
  const textarea = card.querySelector('.step-details');
  textarea.addEventListener('input', ()=>{
    clearTimeout(card._t); card._t = setTimeout(()=>{
      post(base + 'steps/' + id + '/update/', {details:textarea.value});
    }, 400);
  });
  
  // Convert bullets to pills when textarea loses focus
  textarea.addEventListener('blur', ()=>{
    convertBulletsToPills(id, textarea.value);
  });
  
  // Convert bullets to pills on page load
  convertBulletsToPills(id, textarea.value);
  
  // Auto-resize textarea on load and when content changes
  function resizeTextarea() {
    textarea.style.height = 'auto';
    textarea.style.height = textarea.scrollHeight + 'px';
  }
  
  // Resize on load
  resizeTextarea();
  
  // Resize on input
  textarea.addEventListener('input', resizeTextarea);
  
  // Toggle textarea visibility
  const toggleBtn = card.querySelector('.toggle-textarea');
  const toggleText = toggleBtn.querySelector('.toggle-text');
  
  toggleBtn.addEventListener('click', () => {
    if (textarea.style.display === 'none') {
      textarea.style.display = 'block';
      toggleText.textContent = 'Hide Text';
      resizeTextarea();
    } else {
      textarea.style.display = 'none';
      toggleText.textContent = 'Edit Text';
    }
  });
  
  // Track likely insertion bullet index based on caret position while editing
  if (!window.bulletInsertHint) window.bulletInsertHint = {};
  function getBulletIndexAtCaret(ta){
    try {
      const caret = ta.selectionStart || 0;
      const before = ta.value.slice(0, caret).split('\n');
      let idx = -1;
      for (let i = 0; i < before.length; i++) {
        const line = before[i].trimStart();
        if (line.startsWith('- ')) idx++;
      }
      return idx; // -1 if none before caret
    } catch(_) { return null; }
  }
  textarea.addEventListener('keyup', ()=>{
    const idx = getBulletIndexAtCaret(textarea);
    if (idx !== null && idx >= 0) window.bulletInsertHint[id] = idx;
  });
  textarea.addEventListener('click', ()=>{
    const idx = getBulletIndexAtCaret(textarea);
    if (idx !== null && idx >= 0) window.bulletInsertHint[id] = idx;
  });
  
  // Toggle attachments visibility (Links, Documents, Screenshots)
  const toggleAttachmentsBtn = card.querySelector('.toggle-attachments');
  const toggleAttachmentsText = toggleAttachmentsBtn.querySelector('.toggle-text');
  const attachmentsSections = card.querySelectorAll('.step-attachments');
  
  // Set initial button text since attachments are hidden by default
  toggleAttachmentsText.textContent = 'Show Attachments';
  
  toggleAttachmentsBtn.addEventListener('click', () => {
    const isHidden = attachmentsSections[0].style.display === 'none';
    
    attachmentsSections.forEach(section => {
      section.style.display = isHidden ? 'block' : 'none';
    });
    
    toggleAttachmentsText.textContent = isHidden ? 'Hide Attachments' : 'Show Attachments';
  });
  
  // Toggle PDFs visibility for this step
  const togglePdfsBtn = card.querySelector('.toggle-pdfs-step');
  const togglePdfsText = togglePdfsBtn.querySelector('.toggle-text');
  const pdfSection = card.querySelector('#pdfs-' + id);
  
  // Set initial button text since PDFs are hidden by default
  togglePdfsText.textContent = 'Show PDFs';
  
  togglePdfsBtn.addEventListener('click', () => {
    if (pdfSection) {
      const isHidden = pdfSection.style.display === 'none' || pdfSection.style.display === '';
      
      pdfSection.style.display = isHidden ? 'block' : 'none';
      
      togglePdfsText.textContent = isHidden ? 'Hide PDFs' : 'Show PDFs';
    }
  });

  // Clear image connections for this step
  const clearBtn = card.querySelector('.clear-image-links');
  if (clearBtn) {
    clearBtn.addEventListener('click', async ()=>{
      try {
        const url = base + 'steps/' + id + '/images/clear-substeps/';
        const res = await fetch(url, { method:'POST', headers:{ 'X-CSRFToken': getCookie('csrftoken') } });
        const data = await res.json();
        if (data && data.ok) {
          // Reset data-substep-index attributes for images in this step
          const imgGrid = document.getElementById('imgs-' + id);
          if (imgGrid) {
            imgGrid.querySelectorAll('.draggable-img').forEach(el => el.setAttribute('data-substep-index', ''));
          }
          // Provide a brief toast
          showToast(`Cleared ${data.cleared || 0} image connection(s). Drag images to bullets to reassign.`);
        }
      } catch (err) {
        console.error('Failed to clear image connections:', err);
        showToast('Failed to clear image connections', 'error');
      }
    });
  }
  
  
  card.querySelector('.step-delete').addEventListener('click', ()=>{
    post(base + 'steps/' + id + '/delete/').then(()=>location.reload());
  });
});

// Drag and drop ordering
let dragEl = null;

// Initialize drag and drop when DOM is ready
document.addEventListener('DOMContentLoaded', function() {
  // Restore saved module selection
  try {
    const savedModule = localStorage.getItem('process_creator_selected_module');
    if (savedModule) {
      const moduleSelect = document.getElementById('process-module');
      if (moduleSelect && moduleSelect.querySelector(`option[value="${savedModule}"]`)) {
        moduleSelect.value = savedModule;
      }
    }
  } catch(e) {
    console.warn('Could not restore module selection:', e);
  }

  console.log('Setting up drag and drop...');
  const dragHandles = document.querySelectorAll('#steps .card .drag');
  console.log('Found drag handles:', dragHandles.length);
  
  dragHandles.forEach(handle => {
    const card = handle.closest('.card');
    if (card) {
      card.draggable = true;
      console.log('Made card draggable:', card.dataset.id);
      
      card.addEventListener('dragstart', (e) => {
        console.log('Drag started');
        dragEl = card;
        card.style.transition = 'all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
        card.classList.add('opacity-70');
        card.style.transform = 'scale(0.99)';
      });
      
      card.addEventListener('dragend', (e) => {
        console.log('Drag ended');
        card.style.transition = 'all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
        card.classList.remove('opacity-70');
        card.style.transform = 'scale(1)';
        dragEl = null;
        updateStepNumbers(); // Update numbers immediately
        updateStepNavigation(); // Update navigation
        saveOrder();
      });
    }
  });
});

// Set up dragover and drop events
document.addEventListener('DOMContentLoaded', function() {
  const stepsContainer = document.getElementById('steps');
  if (stepsContainer) {
    stepsContainer.addEventListener('dragover', (e) => {
      e.preventDefault();
      const container = e.currentTarget;
      const afterEl = Array.from(container.querySelectorAll('.card')).find(el => {
        const rect = el.getBoundingClientRect();
        return e.clientY < rect.top + rect.height / 2;
      });
      if (!afterEl) container.appendChild(dragEl); 
      else container.insertBefore(dragEl, afterEl);
    });
  }
});

function updateStepNumbers(){
  // Update step number circles in UI immediately
  const cards = Array.from(document.querySelectorAll('#steps .card'));
  cards.forEach((card, index) => {
    const stepNumberCircle = card.querySelector('.absolute.-top-3');
    if (stepNumberCircle) {
      // Update the entire HTML to preserve formatting
      stepNumberCircle.innerHTML = `<div class="w-8 h-8 rounded-full bg-blue-500 text-white flex items-center justify-center text-sm font-bold shadow-lg border-2 border-white">${index + 1}</div>`;
    }
  });
}

function updateImageNumbers(container){
  // Update image number circles in UI immediately
  const images = Array.from(container.querySelectorAll('.draggable-img'));
  images.forEach((img, index) => {
    img.setAttribute('data-order', index + 1);
    const numberCircle = img.querySelector('.absolute.-top-2.-left-2');
    if (numberCircle) {
      numberCircle.textContent = index + 1;
    }
  });
  
  // Save the new order to the server
  const stepId = container.getAttribute('data-step-id');
  if (stepId) {
    const imgIds = images.map(img => img.getAttribute('data-img-id'));
    const formData = new FormData();
    imgIds.forEach(id => formData.append('order[]', id));
    
    fetch(base + 'steps/' + stepId + '/images/reorder/', {
      method: 'POST',
      headers: { 'X-CSRFToken': getCookie('csrftoken') },
      body: formData
    }).catch(err => console.error('Failed to save image order:', err));
  }
}

function saveOrder(){
  const ids = Array.from(document.querySelectorAll('#steps .card')).map(c=>c.dataset.id);
  const form = new URLSearchParams(); ids.forEach(id=>form.append('order[]', id));
  fetch(base + 'steps/reorder/', {method:'POST', headers:{'X-CSRFToken': getCookie('csrftoken')}, body:form});
}

// Copy markdown to clipboard
document.getElementById('copy-btn').addEventListener('click', async (e)=>{
  e.preventDefault();
  const url = e.currentTarget.dataset.copyUrl;
  try {
    const res = await fetch(url);
    const text = await res.text();
    await navigator.clipboard.writeText(text);
    const toast = document.createElement('div');
    toast.className = 'toast toast-top toast-end';
    toast.innerHTML = '<div class="alert alert-success"><span>Copied Markdown to clipboard.</span></div>';
    document.body.appendChild(toast);
    setTimeout(()=>toast.remove(), 1500);
  } catch(err) {
    const toast = document.createElement('div');
    toast.className = 'toast toast-top toast-end';
    toast.innerHTML = '<div class="alert alert-error"><span>Copy failed.</span></div>';
    document.body.appendChild(toast);
    setTimeout(()=>toast.remove(), 2000);
  }
});

// If a step is focused (Focus This Only), append focused_step to Save links
function updateDownloadLinksForFocus() {
  const focused = focusedStepId;
  const pdfBtn = document.getElementById('pdf-btn');
  const wordBtn = document.getElementById('word-btn');
  function withParam(url, key, val) {
    try {
      const u = new URL(url, window.location.origin);
      u.searchParams.set(key, val);
      return u.pathname + u.search;
    } catch(_) { return url; }
  }
  // Only update href if element is an anchor
  if (pdfBtn && pdfBtn.tagName === 'A' && pdfBtn.href) {
    pdfBtn.href = withParam(pdfBtn.href, 'focused_step', focused || '');
  }
  if (wordBtn && wordBtn.tagName === 'A' && wordBtn.href) {
    let wordUrl = withParam(wordBtn.href, 'focused_step', focused || '');
    // Add toggle states for Word export (ALL toggles)
    wordUrl = withParam(wordUrl, 'show_description', document.getElementById('toggle-description').checked);
    wordUrl = withParam(wordUrl, 'show_notes', document.getElementById('toggle-notes').checked);
    wordUrl = withParam(wordUrl, 'show_analysis', document.getElementById('toggle-analysis').checked);
    wordUrl = withParam(wordUrl, 'show_summary', document.getElementById('toggle-summary').checked);
    wordUrl = withParam(wordUrl, 'show_attachments', document.getElementById('toggle-images').checked);
    wordUrl = withParam(wordUrl, 'show_pdfs', document.getElementById('toggle-pdfs').checked);
    wordBtn.href = wordUrl;
  }
}

// Initialize once and safely wrap focus functions after they're defined
document.addEventListener('DOMContentLoaded', function(){
  updateDownloadLinksForFocus();
  try {
    if (typeof window.enterFocusMode === 'function' && !window._enterFocusModeWrapped) {
      const _origEnter = window.enterFocusMode;
      window.enterFocusMode = function(stepId){ _origEnter(stepId); focusedStepId = String(stepId); updateDownloadLinksForFocus(); };
      window._enterFocusModeWrapped = true;
    }
    if (typeof window.exitFocusMode === 'function' && !window._exitFocusModeWrapped) {
      const _origExit = window.exitFocusMode;
      window.exitFocusMode = function(){ _origExit(); focusedStepId = null; updateDownloadLinksForFocus(); };
      window._exitFocusModeWrapped = true;
    }
  } catch(_) {}
});

// Keep export links in sync when toggles change
['toggle-description','toggle-notes','toggle-analysis','toggle-summary','toggle-images','toggle-pdfs'].forEach(id=>{
  const el = document.getElementById(id);
  if (el) el.addEventListener('change', updateDownloadLinksForFocus);
});

// Ensure href is refreshed at click time so parameters are present in the request
const wordBtnEl = document.getElementById('word-btn');
if (wordBtnEl) {
  wordBtnEl.addEventListener('click', (e) => {
    e.preventDefault();
    // Refresh href with current params using the existing updater
    updateDownloadLinksForFocus();
    // Navigate to refreshed href
    window.location.href = wordBtnEl.href;
  });
}


// Image uploads via file input
document.querySelectorAll('input[data-upload-step]').forEach(input=>{
  input.addEventListener('change', async (e)=>{
    const stepId = e.currentTarget.getAttribute('data-upload-step');
    for (const file of e.currentTarget.files) {
      const fd = new FormData(); fd.append('image', file);
      const res = await fetch(base + 'steps/' + stepId + '/images/upload/', {method:'POST', headers:{'X-CSRFToken': getCookie('csrftoken')}, body: fd});
      const data = await res.json(); if (data.ok) addThumb(stepId, data);
    }
    e.currentTarget.value = '';
  });
});

// Dedicated button opens file input
document.querySelectorAll('[data-open-upload]').forEach(btn=>{
  btn.addEventListener('click', (e)=>{
    e.preventDefault();
    const stepId = e.currentTarget.getAttribute('data-open-upload');
    const input = document.querySelector(`input[data-upload-step="${stepId}"]`);
    if (input) input.click();
  });
});

// Master toggle show/hide all attachments (display only; print unaffected)
const imgToggle = document.getElementById('toggle-images');
const TOGGLE_KEY = 'process_creator_show_attachments';
function applyAttachmentVisibility(){
  const show = imgToggle.checked;
  // Hide/show images
  document.querySelectorAll('.img-section').forEach(sec=>{
    sec.style.display = show ? '' : 'none';
  });
  // Hide/show documents (PDFs/CAD files)
  document.querySelectorAll('.mt-3').forEach(sec=>{
    if (sec.querySelector('.text-sm.opacity-70')?.textContent?.includes('Documents')) {
      sec.style.display = show ? '' : 'none';
    }
  });
  // Hide/show links
  document.querySelectorAll('.mt-3').forEach(sec=>{
    if (sec.querySelector('.text-sm.opacity-70')?.textContent?.includes('Links')) {
      sec.style.display = show ? '' : 'none';
    }
  });
  try { localStorage.setItem(TOGGLE_KEY, show ? '1' : '0'); } catch(e) {}
}
// Initialize from localStorage (default: off)
try {
  const saved = localStorage.getItem(TOGGLE_KEY);
  if (saved === '1') imgToggle.checked = true;
} catch(e) {}
imgToggle.addEventListener('change', applyAttachmentVisibility);
// Apply once on load
applyAttachmentVisibility();

// Toggle for Process Summary section
const summaryToggle = document.getElementById('toggle-summary');
const SUMMARY_TOGGLE_KEY = 'process_creator_show_summary';
function applySummaryVisibility() {
  const show = summaryToggle.checked;
  const summarySection = document.getElementById('summary-section');
  if (summarySection) {
    summarySection.style.display = show ? '' : 'none';
  }
  try { localStorage.setItem(SUMMARY_TOGGLE_KEY, show ? '1' : '0'); } catch(e) {}
}
// Initialize from localStorage (default: off)
try {
  const saved = localStorage.getItem(SUMMARY_TOGGLE_KEY);
  if (saved === '1') summaryToggle.checked = true;
} catch(e) {}
summaryToggle.addEventListener('change', applySummaryVisibility);
// Apply once on load
applySummaryVisibility();

// Toggle for Process Analysis section
const analysisToggle = document.getElementById('toggle-analysis');
const ANALYSIS_TOGGLE_KEY = 'process_creator_show_analysis';
function applyAnalysisVisibility() {
  const show = analysisToggle.checked;
  const analysisSection = document.getElementById('analysis-section');
  if (analysisSection) {
    analysisSection.style.display = show ? '' : 'none';
  }
  try { localStorage.setItem(ANALYSIS_TOGGLE_KEY, show ? '1' : '0'); } catch(e) {}
}
// Initialize from localStorage (default: off)
try {
  const saved = localStorage.getItem(ANALYSIS_TOGGLE_KEY);
  if (saved === '1') analysisToggle.checked = true;
} catch(e) {}
analysisToggle.addEventListener('change', applyAnalysisVisibility);
// Apply once on load
applyAnalysisVisibility();

// Toggle for Description section
const descriptionToggle = document.getElementById('toggle-description');
const DESCRIPTION_TOGGLE_KEY = 'process_creator_show_description';
function applyDescriptionVisibility() {
  const show = descriptionToggle.checked;
  const descriptionSection = document.getElementById('description-section');
  if (descriptionSection) {
    descriptionSection.style.display = show ? '' : 'none';
  }
  try { localStorage.setItem(DESCRIPTION_TOGGLE_KEY, show ? '1' : '0'); } catch(e) {}
}
// Initialize from localStorage (default: off)
try {
  const saved = localStorage.getItem(DESCRIPTION_TOGGLE_KEY);
  if (saved === '1') descriptionToggle.checked = true;
} catch(e) {}
descriptionToggle.addEventListener('change', applyDescriptionVisibility);
// Apply once on load
applyDescriptionVisibility();

// Toggle for Notes section
const notesToggle = document.getElementById('toggle-notes');
const NOTES_TOGGLE_KEY = 'process_creator_show_notes';
function applyNotesVisibility() {
  const show = notesToggle.checked;
  const notesSection = document.getElementById('notes-section');
  if (notesSection) {
    notesSection.style.display = show ? '' : 'none';
  }
  try { localStorage.setItem(NOTES_TOGGLE_KEY, show ? '1' : '0'); } catch(e) {}
}
// Initialize from localStorage (default: off)
try {
  const saved = localStorage.getItem(NOTES_TOGGLE_KEY);
  if (saved === '1') notesToggle.checked = true;
} catch(e) {}
notesToggle.addEventListener('change', applyNotesVisibility);
// Apply once on load
applyNotesVisibility();

// PDFs toggle functionality
const PDFS_TOGGLE_KEY = 'process_creator_pdfs_toggle';
const pdfsToggle = document.getElementById('toggle-pdfs');
function applyPdfsVisibility() {
  const show = pdfsToggle.checked;
  // Show/hide PDF sections in all steps
  document.querySelectorAll('.step-attachments').forEach(section => {
    const pdfSection = section.querySelector('#pdfs-' + section.id.split('-')[1]);
    if (pdfSection) {
      pdfSection.style.display = show ? '' : 'none';
    }
  });
  try { localStorage.setItem(PDFS_TOGGLE_KEY, show ? '1' : '0'); } catch(e) {}
}
// Initialize from localStorage (default: off)
try {
  const saved = localStorage.getItem(PDFS_TOGGLE_KEY);
  if (saved === '1') pdfsToggle.checked = true;
} catch(e) {}
pdfsToggle.addEventListener('change', applyPdfsVisibility);
// Apply once on load
applyPdfsVisibility();

// Stats modal functionality
document.getElementById('stats-btn').addEventListener('click', async (e)=>{
  e.preventDefault();
  const modal = document.getElementById('stats-modal');
  const content = document.getElementById('stats-content');
  
  try {
    const res = await fetch(`/process-creator/${processId}/stats/`);
    const data = await res.json();
    
    content.innerHTML = `
      <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
        <!-- Timeline Section -->
        <div class="card bg-base-200 shadow-sm">
          <div class="card-body p-4">
            <h4 class="card-title text-lg text-primary mb-4">📅 Timeline</h4>
            <div class="space-y-3">
              <div class="flex items-center gap-3">
                <div class="badge badge-primary badge-sm">Created</div>
                <div class="text-sm font-medium">${data.created_at}</div>
              </div>
              <div class="flex items-center gap-3">
                <div class="badge badge-secondary badge-sm">Updated</div>
                <div class="text-sm font-medium">${data.updated_at}</div>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Content Stats -->
        <div class="card bg-base-200 shadow-sm">
          <div class="card-body p-4">
            <h4 class="card-title text-lg text-accent mb-4">📝 Content</h4>
            <div class="space-y-3">
              <div class="flex justify-between items-center">
                <span class="text-sm opacity-70">Steps</span>
                <div class="badge badge-accent badge-lg">${data.step_count}</div>
              </div>
              <div class="flex justify-between items-center">
                <span class="text-sm opacity-70">Substeps</span>
                <div class="badge badge-secondary badge-lg">${data.substep_count || 0}</div>
              </div>
              <div class="flex justify-between items-center">
                <span class="text-sm opacity-70">Total Steps</span>
                <div class="badge badge-primary badge-lg">${data.total_steps || data.step_count}</div>
              </div>
              <div class="flex justify-between items-center">
                <span class="text-sm opacity-70">Images</span>
                <div class="badge badge-accent badge-lg">${data.image_count}</div>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Text Stats -->
        <div class="card bg-base-200 shadow-sm">
          <div class="card-body p-4">
            <h4 class="card-title text-lg text-info mb-4">📄 Text Content</h4>
            <div class="space-y-3">
              <div class="flex justify-between items-center">
                <span class="text-sm opacity-70">Description</span>
                <div class="text-sm font-medium">${data.description_length || 0} chars</div>
              </div>
              <div class="flex justify-between items-center">
                <span class="text-sm opacity-70">Notes</span>
                <div class="text-sm font-medium">${data.notes_length || 0} chars</div>
              </div>
              <div class="flex justify-between items-center">
                <span class="text-sm opacity-70">Summary</span>
                <div class="text-sm font-medium">${data.summary_length || 0} chars</div>
              </div>
              <div class="flex justify-between items-center">
                <span class="text-sm opacity-70">Analysis</span>
                <div class="text-sm font-medium">${data.analysis_length || 0} chars</div>
              </div>
              <div class="flex justify-between items-center">
                <span class="text-sm opacity-70">Step Details</span>
                <div class="text-sm font-medium">${data.step_details_length || 0} chars</div>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Summary Stats -->
        <div class="card bg-gradient-to-br from-primary to-secondary text-primary-content shadow-lg">
          <div class="card-body p-4">
            <h4 class="card-title text-lg mb-4">🎯 Summary</h4>
            <div class="space-y-2">
              <div class="flex justify-between">
                <span class="text-sm opacity-90">Total Content</span>
                <span class="font-bold">${(data.total_steps || data.step_count) + data.image_count} items</span>
              </div>
              <div class="flex justify-between">
                <span class="text-sm opacity-90">Text Length</span>
                <span class="font-bold">${data.total_text_length || 0} chars</span>
              </div>
              <div class="divider my-2"></div>
              <div class="text-center">
                <div class="text-2xl font-bold">${(data.total_steps || data.step_count) > 0 ? Math.round(data.image_count / (data.total_steps || data.step_count) * 10) / 10 : 0}</div>
                <div class="text-sm opacity-90">images per step</div>
              </div>
            </div>
          </div>
        </div>
      </div>
    `;
    
    modal.showModal();
  } catch(err) {
    content.innerHTML = `
      <div class="alert alert-error">
        <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" />
        </svg>
        <span>Failed to load statistics. Please try again.</span>
      </div>
    `;
    modal.showModal();
  }
});

// AI Create Summary
document.getElementById('create-summary-btn').addEventListener('click', async (e)=>{
  e.preventDefault();
  const btn = e.target;
  const originalText = btn.innerHTML;
  
  try {
    btn.disabled = true;
    btn.innerHTML = '<i class="fas fa-spinner fa-spin mr-1"></i>Creating...';
    
    const instructions = document.getElementById('summary-instructions').value;
    const res = await fetch(`/process-creator/${processId}/ai/summary/`, {
      method: 'POST',
      headers: {'X-CSRFToken': getCookie('csrftoken'), 'Content-Type': 'application/json'},
      body: JSON.stringify({instructions: instructions})
    });
    
    if (!res.ok) {
      throw new Error(`HTTP error! status: ${res.status}`);
    }
    
    const data = await res.json();
    if (data.success) {
      document.getElementById('process-summary').value = data.summary;
      
      // Show success toast
      const toast = document.createElement('div');
      toast.className = 'toast toast-top toast-end';
      toast.innerHTML = '<div class="alert alert-success"><span>Process summary created successfully!</span></div>';
      document.body.appendChild(toast);
      setTimeout(()=>toast.remove(), 3000);
    } else {
      throw new Error(data.error || 'Failed to generate process summary');
    }
  } catch(err) {
    const toast = document.createElement('div');
    toast.className = 'toast toast-top toast-end';
    toast.innerHTML = '<div class="alert alert-error"><span>Failed to create process summary: ' + err.message + '</span></div>';
    document.body.appendChild(toast);
    setTimeout(()=>toast.remove(), 5000);
  } finally {
    btn.disabled = false;
    btn.innerHTML = originalText;
  }
});

// AI Analysis
document.getElementById('analyze-btn').addEventListener('click', async (e)=>{
  e.preventDefault();
  const btn = e.target;
  const originalText = btn.innerHTML;
  
  try {
    btn.disabled = true;
    btn.innerHTML = '<i class="fas fa-spinner fa-spin mr-1"></i>Analyzing...';
    
    const instructions = document.getElementById('analysis-instructions').value;
    const res = await fetch(`/process-creator/${processId}/ai/analyze/`, {
      method: 'POST',
      headers: {'X-CSRFToken': getCookie('csrftoken'), 'Content-Type': 'application/json'},
      body: JSON.stringify({instructions: instructions})
    });
    
    if (!res.ok) {
      throw new Error(`HTTP error! status: ${res.status}`);
    }
    
    const data = await res.json();
    if (data.success) {
      document.getElementById('process-analysis').value = data.analysis;
      
      // Show success toast
      const toast = document.createElement('div');
      toast.className = 'toast toast-top toast-end';
      toast.innerHTML = '<div class="alert alert-success"><span>Process analysis completed successfully!</span></div>';
      document.body.appendChild(toast);
      setTimeout(()=>toast.remove(), 3000);
    } else {
      throw new Error(data.error || 'Failed to generate analysis');
    }
  } catch(err) {
    const toast = document.createElement('div');
    toast.className = 'toast toast-top toast-end';
    toast.innerHTML = '<div class="alert alert-error"><span>Failed to generate process analysis: ' + err.message + '</span></div>';
    document.body.appendChild(toast);
    setTimeout(()=>toast.remove(), 5000);
  } finally {
    btn.disabled = false;
    btn.innerHTML = originalText;
  }
});

// Image click handler - open images in modal
document.addEventListener('click', (e) => {
  // Check if clicked element is an image within a step
  if (e.target.tagName === 'IMG' && e.target.closest('[id^="imgs-"]')) {
    e.preventDefault();
    const imgSrc = e.target.src;
    const modal = document.getElementById('image-modal');
    // reset zoom/position
    currentScale = 1; offsetX = 0; offsetY = 0; applyTransform();
    // ensure image element is restored in stage
    const stage = document.getElementById('zoom-stage');
    stage.innerHTML = '';
    const imgEl = document.createElement('img');
    imgEl.id = 'modal-image';
    imgEl.alt = 'Full size image';
    imgEl.className = 'select-none cursor-move will-change-transform';
    imgEl.style.width = '100%'; imgEl.style.height = '100%'; imgEl.style.objectFit = 'contain';
    imgEl.style.transform = 'translate(0px,0px) scale(1)';
    imgEl.src = imgSrc;
    stage.appendChild(imgEl);
    modalImgEl = imgEl;
    modal.showModal();
  }
});

// Image grid click handler removed - only "Add images" button opens file dialog

// Track last focused/clicked step for paste fallback
let lastFocusedStepId = null;
const lastFocusedBulletIndexByStep = {};
document.addEventListener('focusin', (e) => {
  const card = e.target && e.target.closest && e.target.closest('.step-card');
  if (card) lastFocusedStepId = card.dataset.id;
});
document.getElementById('steps').addEventListener('mousedown', (e) => {
  const card = e.target && e.target.closest && e.target.closest('.step-card');
  if (card) lastFocusedStepId = card.dataset.id;
});

// Track last clicked pill index per step (so pasting can attach to that substep)
document.addEventListener('mousedown', (e) => {
  const pill = e.target && e.target.closest && e.target.closest('.draggable-pill');
  if (!pill) return;
  const stepCard = pill.closest('.step-card');
  if (!stepCard) return;
  const stepId = stepCard.dataset.id;
  const idxAttr = pill.getAttribute('data-index');
  if (idxAttr != null) lastFocusedBulletIndexByStep[stepId] = parseInt(idxAttr, 10);
});

// Paste handler on window - attach to nearest focused step card
document.addEventListener('paste', async (e)=>{
  const items = e.clipboardData && e.clipboardData.items; if (!items) return;
  let file = null; let urlText = null; let pdfFile = null; let cadFile = null;
  const textPromise = new Promise(resolve=>{
    let resolved = false;
    for (const it of items) {
      if (it.kind === 'string' && it.type === 'text/plain') {
        it.getAsString(t=>{ if (!resolved){ urlText = t; resolved = true; resolve(); } });
      }
    }
    // Fallback resolve quickly if no text item
    setTimeout(()=>{ if (!resolved) resolve(); }, 0);
  });
  for (const it of items) {
    if (it.type && it.type.indexOf('image') !== -1) { file = it.getAsFile(); }
    if (it.type === 'application/pdf') { pdfFile = it.getAsFile(); }
    if (it.kind === 'file' && it.type === '') { // Some CAD types lack a MIME
      const f = it.getAsFile();
      if (f && (/\.dwg$/i.test(f.name) || /\.idw$/i.test(f.name))) cadFile = f;
    }
  }
  await textPromise;
  // find focused step
  const activeCard = document.activeElement && document.activeElement.closest ? document.activeElement.closest('.step-card') : null;
  let stepId = activeCard ? activeCard.dataset.id : (lastFocusedStepId || null);
  if (!stepId) {
    showToast('Click inside a step before pasting.', 'error');
    return;
  }
  // Determine substep index from caret if inside the step textarea
  let substepIndex = null;
  const ta = document.activeElement && document.activeElement.classList && document.activeElement.classList.contains('step-details') ? document.activeElement : null;
  if (ta) {
    try {
      const caret = ta.selectionStart || 0;
      const textUpToCaret = ta.value.slice(0, caret);
      const allLines = ta.value.split('\n');
      const caretLineNumber = textUpToCaret.split('\n').length - 1; // 0-based
      // Compute index among bullet lines (lines starting with '-') up to caret line
      let idx = -1;
      for (let i = 0; i <= caretLineNumber && i < allLines.length; i++) {
        const isBullet = /^\s*-\s?/.test(allLines[i]);
        if (isBullet) idx++;
      }
      // Only set if the caret is within a bullet line
      if (/^\s*-\s?/.test(allLines[Math.max(0, caretLineNumber)] || '')) {
        substepIndex = idx >= 0 ? idx : null;
      }
    } catch(_) {}
  }
  // If not in textarea or no bullet at caret, fall back to last clicked pill
  if ((substepIndex === null || substepIndex === undefined) && lastFocusedBulletIndexByStep[stepId] != null) {
    substepIndex = lastFocusedBulletIndexByStep[stepId];
  }
  // If CAD pasted (DWG / IDW)
  if (cadFile) {
    const fd = new FormData(); fd.append('file', cadFile);
    try {
      const res = await fetch(base + 'steps/' + stepId + '/files/upload/', {method:'POST', headers:{'X-CSRFToken': getCookie('csrftoken')}, body: fd});
      const data = await res.json();
      if (data.ok) {
        // Add a link button with the filename
        addLinkButton(stepId, {title: (cadFile.name || 'Document'), url: data.url});
        // Also show it in the documents grid for download
        addPdfThumb(stepId, data);
      } else {
        showToast(data.error || 'Conversion failed', 'error');
      }
    } catch(err){ showToast('Conversion failed', 'error'); }
    return;
  }
  // If PDF pasted
  if (pdfFile) {
    const fd = new FormData(); fd.append('file', pdfFile);
    try {
      const res = await fetch(base + 'steps/' + stepId + '/files/upload/', {method:'POST', headers:{'X-CSRFToken': getCookie('csrftoken')}, body: fd});
      const data = await res.json(); if (data.ok) addPdfThumb(stepId, data); else showToast(data.error || 'Upload failed', 'error');
    } catch(err){ showToast('Upload failed', 'error'); }
    return;
  }
  // If image pasted
  if (file) {
    const fd = new FormData(); fd.append('file', file);
    if (substepIndex !== null && substepIndex !== undefined) fd.append('substep_index', String(substepIndex));
    const res = await fetch(base + 'steps/' + stepId + '/images/upload/', {method:'POST', headers:{'X-CSRFToken': getCookie('csrftoken')}, body: fd});
    const data = await res.json(); if (data.ok) addThumb(stepId, data);
    return;
  }
  // If plain text URL or Windows path pasted into details
  const pastedText = urlText?.trim();
  if (pastedText && (/^https?:\/\//i.test(pastedText) || /^[A-Za-z]:\\/.test(pastedText))) {
    // prevent the text from being inserted in the textarea
    e.preventDefault();
    const targetTA = e.target.classList.contains('step-details') ? e.target : null;
    
    // Convert Windows path to file:// URL for opening in Explorer
    let linkUrl = pastedText;
    if (/^[A-Za-z]:\\/.test(pastedText)) {
      linkUrl = 'file:///' + pastedText.replace(/\\/g, '/');
    }
    
    // Extract a nice title from the path
    let linkTitle = pastedText;
    if (/^[A-Za-z]:\\/.test(pastedText)) {
      const parts = pastedText.split('\\');
      linkTitle = parts[parts.length - 1] || parts[parts.length - 2] || 'Folder';
    }
    
    openCreateLinkModal(linkUrl, async ({title, url})=>{
      const res = await fetch(base + 'steps/' + stepId + '/links/add/', {method:'POST', headers:{'X-CSRFToken': getCookie('csrftoken'), 'Content-Type':'application/json'}, body: JSON.stringify({title, url})});
      const data = await res.json();
      if (data.ok) {
        addLinkButton(stepId, data);
        if (targetTA) {
          // remove any residual pasted text
          const {selectionStart: s, selectionEnd: epos} = targetTA;
          if (s != null && epos != null && s !== epos) {
            const cur = targetTA.value; targetTA.value = cur.slice(0, s) + cur.slice(epos);
          } else if (targetTA.value.includes(pastedText)) {
            targetTA.value = targetTA.value.replace(pastedText, '');
          }
        }
      }
    }, linkTitle);
  }
});

// Delete image - use event delegation for all images
document.addEventListener('click', async (e)=>{
  const deleteBtn = e.target.closest('.delete-img');
  if (!deleteBtn) return;
  
  e.preventDefault();
  e.stopPropagation();
  
  const stepId = deleteBtn.getAttribute('data-step');
  const id = deleteBtn.getAttribute('data-id');
  
  try {
    await fetch(base + 'steps/' + stepId + '/images/' + id + '/delete/', {
      method:'POST', 
      headers:{'X-CSRFToken': getCookie('csrftoken')}
    });
    deleteBtn.closest('.relative').remove();
    
    // Renumber remaining images after deletion
    const container = document.getElementById(`imgs-${stepId}`);
    if (container) {
      updateImageNumbers(container);
    }
  } catch(err) {
    console.error('Failed to delete image:', err);
  }
});

// Delete link - use event delegation for all links
document.addEventListener('click', async (e)=>{
  const deleteBtn = e.target.closest('.delete-link');
  if (!deleteBtn) return;
  
  e.preventDefault();
  e.stopPropagation();
  
  const stepId = deleteBtn.getAttribute('data-step');
  const id = deleteBtn.getAttribute('data-id');
  
  try {
    await fetch(base + 'steps/' + stepId + '/links/' + id + '/delete/', {
      method:'POST', 
      headers:{'X-CSRFToken': getCookie('csrftoken')}
    });
    deleteBtn.closest('.relative').remove();
  } catch(err) {
    console.error('Failed to delete link:', err);
  }
});

// Delete pill - use event delegation for all pills
document.addEventListener('click', async (e)=>{
  const deleteBtn = e.target.closest('.delete-pill');
  if (!deleteBtn) return;
  
  e.preventDefault();
  e.stopPropagation();
  
  const stepId = deleteBtn.getAttribute('data-step');
  const pill = deleteBtn.closest('.draggable-pill');
  
  if (pill) {
    pill.remove();
    updatePillNumbers(stepId);
    updateTextareaFromPills(stepId);
      renderBulletImageBadges(stepId);
  }
});

function addThumb(stepId, data){
  const container = document.getElementById('imgs-'+stepId);
  const div = document.createElement('div');
  div.className = 'relative group draggable-img';
  div.setAttribute('data-img-id', data.id);
  div.setAttribute('data-order', data.order || 1);
  div.setAttribute('draggable', 'true');
  div.innerHTML = `<img src="${data.url}" class="rounded border object-cover w-full h-28" /><button class="btn btn-xs btn-error absolute top-1 right-1 opacity-0 group-hover:opacity-100 delete-img" data-step="${stepId}" data-id="${data.id}">✕</button><div class="absolute -top-2 -left-2 w-6 h-6 rounded-full bg-secondary text-secondary-content flex items-center justify-center text-xs font-bold shadow-lg z-20 border border-base-100">${data.order || 1}</div>`;
  if (data.substep_index !== null && data.substep_index !== undefined) {
    div.setAttribute('data-substep-index', data.substep_index);
  }
  container.appendChild(div);
  
  // Renumber all images after adding new one
  updateImageNumbers(container);
  // Refresh bullet badges to reflect new connections
  renderBulletImageBadges(stepId);
  
  // Event listener is now handled by event delegation above
}

// Function to initialize auto-resize for a specific textarea
function initAutoResize(textarea) {
  if (textarea.classList.contains('auto-resize')) {
    const minHeight = textarea.offsetHeight;
    textarea.setAttribute('data-min-height', minHeight);
    autoResize(textarea);
    
    textarea.addEventListener('input', () => autoResize(textarea));
    textarea.addEventListener('paste', () => {
      setTimeout(() => autoResize(textarea), 10);
    });
  }
}

function addLinkButton(stepId, data){
  const container = document.getElementById('links-'+stepId);
  const div = document.createElement('div');
  div.className = 'relative group';
  div.innerHTML = `<a href="${data.url}" target="_blank" class="btn btn-outline btn-sm" data-link-id="${data.id}">${data.title}</a><button class="btn btn-xs btn-error absolute -top-2 -right-2 opacity-0 group-hover:opacity-100 delete-link text-xs w-4 h-4 min-h-0 p-0 flex items-center justify-center" data-step="${stepId}" data-id="${data.id}">✕</button>`;
  container.appendChild(div);
}

// Convert bullet points to draggable pills
function convertBulletsToPills(stepId, text) {
  const pillsContainer = document.getElementById(`pills-${stepId}`);
  const pillsList = document.getElementById(`pills-list-${stepId}`);
  
  if (!pillsContainer || !pillsList) return;
  
  // Capture old bullets (by text) before rebuild to preserve image associations
  const oldPills = Array.from(pillsList.querySelectorAll('.draggable-pill'));
  const oldBullets = oldPills.map(p => (p.querySelector('.pill-text')?.textContent || '').trim());
  const oldIndexByOccurrence = {};
  oldBullets.forEach((t, idx) => {
    const key = `${t}__${(oldIndexByOccurrence[t] || 0)}`;
    oldIndexByOccurrence[t] = (oldIndexByOccurrence[t] || 0) + 1;
    oldIndexByOccurrence[key] = idx;
  });

  // Extract bullet points (lines starting with -)
  const bullets = text.split('\n')
    .map(line => line.trim())
    .filter(line => line.startsWith('-'))
    .map(line => line.substring(1).trim())
    .filter(line => line.length > 0);
  
  if (bullets.length === 0) {
    pillsContainer.style.display = 'none';
    return;
  }
  
  // Show container and populate pills
  pillsContainer.style.display = 'block';
  pillsList.innerHTML = '';
  
  // Build new pills and track new indices by (text, occurrence)
  const newIndexByOccurrence = {};
  const newIndexMap = {};
  bullets.forEach((bullet, index) => {
    const pill = document.createElement('div');
    pill.className = 'draggable-pill bg-base-100 border border-base-300 p-1.5 md:p-2 text-sm cursor-grab hover:border-primary/40 transition-all duration-200 flex items-center gap-2';
    pill.setAttribute('draggable', 'true');
    pill.setAttribute('data-index', index);
    pill.innerHTML = `
      <span class="pill-number text-xs font-bold bg-primary text-primary-content px-2 py-1 rounded-full flex-shrink-0">${index + 1}</span>
      <span class="linked-images ml-1 flex items-center gap-1"></span>
      <span class="pill-text text-sm leading-relaxed break-words flex-1">${bullet}</span>
      <button class="delete-pill text-xs hover:text-error ml-2 flex-shrink-0 opacity-70 hover:opacity-100 transition-opacity" data-step="${stepId}" data-index="${index}">✕</button>
    `;
    pillsList.appendChild(pill);
    const occ = newIndexByOccurrence[bullet] || 0;
    newIndexByOccurrence[bullet] = occ + 1;
    newIndexMap[`${bullet}__${occ}`] = index;
  });
  // Render image badges next to bullets showing linked image numbers
  renderBulletImageBadges(stepId);
  
  // Compute mapping oldIndex -> newIndex via LCS-based diff with fallbacks
  let oldToNew = {};
  function lcsPairs(a, b){
    const n = a.length, m = b.length;
    const dp = Array.from({length:n+1}, ()=>Array(m+1).fill(0));
    for (let i=1;i<=n;i++){
      for (let j=1;j<=m;j++){
        dp[i][j] = a[i-1] === b[j-1] ? dp[i-1][j-1]+1 : Math.max(dp[i-1][j], dp[i][j-1]);
      }
    }
    const pairs = [];
    let i=n, j=m;
    while(i>0 && j>0){
      if (a[i-1] === b[j-1]){ pairs.push([i-1,j-1]); i--; j--; }
      else if (dp[i-1][j] >= dp[i][j-1]) i--; else j--;
    }
    return pairs.reverse();
  }
  const pairs = lcsPairs(oldBullets, bullets);
  if (Math.abs(bullets.length - oldBullets.length) === 1 && pairs.length){
    // Determine insertion/deletion index from first gap in pairs
    const inserted = bullets.length > oldBullets.length;
    let idx = 0;
    for (let k=0;k<=pairs.length;k++){
      const prevOld = k?pairs[k-1][0]:-1;
      const prevNew = k?pairs[k-1][1]:-1;
      const nextOld = k<pairs.length?pairs[k][0]:oldBullets.length;
      const nextNew = k<pairs.length?pairs[k][1]:bullets.length;
      const oldGap = nextOld - prevOld - 1;
      const newGap = nextNew - prevNew - 1;
      if (inserted && newGap === 1 && oldGap === 0){ idx = prevNew + 1; break; }
      if (!inserted && oldGap === 1 && newGap === 0){ idx = prevOld + 1; break; }
    }
    if (inserted){
      for (let oi=0; oi<oldBullets.length; oi++) oldToNew[oi] = oi < idx ? oi : oi+1;
    }else{
      for (let oi=0; oi<oldBullets.length; oi++){
        if (oi < idx) oldToNew[oi] = oi; else if (oi > idx) oldToNew[oi] = oi-1; // oi==idx deleted
      }
    }
  } else {
    // Many edits: map by text occurrences but do NOT attach images to brand new bullets
    const seenOccurrence = {};
    oldBullets.forEach((t, oldIdx) => {
      const occ = seenOccurrence[t] || 0; seenOccurrence[t] = occ + 1;
      const key = `${t}__${occ}`;
      if (key in newIndexMap) oldToNew[oldIdx] = newIndexMap[key];
    });
  }

  // Apply mapping to images for this step
  updateImagesForPillReorder(stepId, oldToNew);

  // Add drag and drop functionality
  setupPillDragAndDrop(stepId);
}

// Setup drag and drop for pills
function setupPillDragAndDrop(stepId) {
  const pillsList = document.getElementById(`pills-list-${stepId}`);
  if (!pillsList) return;
  
  let draggedPill = null;
  let snapshotOrder = [];
  
  // Get all pills in current order
  function getAllPills() {
    return Array.from(pillsList.querySelectorAll('.draggable-pill'));
  }
  
  // Find the best drop position
  function getDropPosition(y) {
    const pills = getAllPills().filter(p => p !== draggedPill);
    if (pills.length === 0) return { after: null, before: null };
    
    for (let i = 0; i < pills.length; i++) {
      const pill = pills[i];
      const rect = pill.getBoundingClientRect();
      const pillCenterY = rect.top + rect.height / 2;
      
      if (y < pillCenterY) {
        return { after: null, before: pill };
      }
    }
    return { after: pills[pills.length - 1], before: null };
  }
  
  // Drag start
  pillsList.addEventListener('dragstart', (e) => {
    if (e.target.closest('.draggable-pill')) {
      draggedPill = e.target.closest('.draggable-pill');
      e.target.style.opacity = '0.5';
      // Snapshot original indices before any movement
      snapshotOrder = getAllPills();
      snapshotOrder.forEach((pill, idx) => {
        pill.setAttribute('data-old-index', pill.getAttribute('data-index') || idx);
      });
    }
  });
  
  // Drag end
  pillsList.addEventListener('dragend', (e) => {
    if (e.target.closest('.draggable-pill')) {
      e.target.style.opacity = '';
      draggedPill = null;
      // Build mapping oldIndex -> newIndex
      const mapping = {};
      const current = getAllPills();
      current.forEach((pill, newIdx) => {
        const oldIdxStr = pill.getAttribute('data-old-index');
        if (oldIdxStr !== null) {
          const oldIdx = parseInt(oldIdxStr, 10);
          if (!Number.isNaN(oldIdx) && oldIdx !== newIdx) {
            mapping[oldIdx] = newIdx;
          }
          pill.removeAttribute('data-old-index');
        }
      });
      if (Object.keys(mapping).length > 0) {
        updateImagesForPillReorder(stepId, mapping);
      }
  // Refresh badges after reordering
  renderBulletImageBadges(stepId);
    }
  });
  
  // Drag over with auto-scroll support at viewport edges
  pillsList.addEventListener('dragover', (e) => {
    e.preventDefault();
    // Auto-scroll when near window edges to allow long lists
    const edge = 60; // px
    if (e.clientY < edge) {
      window.scrollBy(0, -12);
    } else if (window.innerHeight - e.clientY < edge) {
      window.scrollBy(0, 12);
    }
    const position = getDropPosition(e.clientY);
    
    if (position.before) {
      pillsList.insertBefore(draggedPill, position.before);
    } else if (position.after) {
      if (position.after.nextSibling) {
        pillsList.insertBefore(draggedPill, position.after.nextSibling);
      } else {
        pillsList.appendChild(draggedPill);
      }
    } else {
      pillsList.appendChild(draggedPill);
    }
    
    updatePillNumbers(stepId);
    updateTextareaFromPills(stepId);
  });
  
  // Prevent text selection while dragging
  pillsList.addEventListener('selectstart', (e) => {
    if (e.target.closest('.draggable-pill')) {
      e.preventDefault();
    }
  });
}

// Update image substep indices for a step using an old->new index mapping
async function updateImagesForPillReorder(stepId, oldToNewMap) {
  try {
    const imgGrid = document.getElementById(`imgs-${stepId}`);
    if (!imgGrid) return;
    const imgs = Array.from(imgGrid.querySelectorAll('.draggable-img'));
    const base = window.location.pathname.replace(/\/$/, '/')
      .replace(/(\d+)\/$/.test(window.location.pathname) ? /(\d+)\/$/ : /$/, `${stepId}/`);
    for (const imgEl of imgs) {
      const imgId = imgEl.getAttribute('data-img-id');
      const substepStr = imgEl.getAttribute('data-substep-index');
      if (substepStr === null || substepStr === '') continue;
      const oldIdx = parseInt(substepStr, 10);
      if (Number.isNaN(oldIdx)) continue;
      if (oldToNewMap.hasOwnProperty(oldIdx)) {
        const newIdx = oldToNewMap[oldIdx];
        // Update server
        const url = base.replace(/(\d+)\/$/.test(base) ? /(\d+)\/$/ : /$/, '') + `steps/${stepId}/images/${imgId}/update-substep/`;
        await fetch(url, {
          method: 'POST',
          headers: {
            'X-Requested-With': 'XMLHttpRequest',
            'X-CSRFToken': getCSRFToken(),
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ substep_index: newIdx })
        });
        // Update DOM attribute
        imgEl.setAttribute('data-substep-index', String(newIdx));
      }
    }
  } catch (err) {
    console.error('Failed to update image substep indices after reorder:', err);
  }
}

// Update pill numbers after reordering
function updatePillNumbers(stepId) {
  const pillsList = document.getElementById(`pills-list-${stepId}`);
  if (!pillsList) return;
  
  const pills = Array.from(pillsList.querySelectorAll('.draggable-pill'));
  pills.forEach((pill, index) => {
    const numberSpan = pill.querySelector('.pill-number');
    if (numberSpan) {
      numberSpan.textContent = index + 1;
    }
    pill.setAttribute('data-index', index);
  });
}

// Update textarea content from pills
function updateTextareaFromPills(stepId) {
  const pillsList = document.getElementById(`pills-list-${stepId}`);
  const textarea = document.querySelector(`[data-id="${stepId}"] .step-details`);
  
  if (!pillsList || !textarea) return;
  
  const pills = Array.from(pillsList.querySelectorAll('.draggable-pill'));
  const bulletText = pills.map(pill => {
    const textSpan = pill.querySelector('.pill-text');
    return textSpan ? `- ${textSpan.textContent}` : '';
  }).join('\n');
  
  textarea.value = bulletText;
  
  // Auto-resize textarea after updating content
  autoResize(textarea);
  
  // Save to server
  post(base + 'steps/' + stepId + '/update/', {details: textarea.value});
}

// Render small image number badges next to each bullet to visualize connections
function renderBulletImageBadges(stepId){
  const pillsList = document.getElementById(`pills-list-${stepId}`);
  const imgGrid = document.getElementById(`imgs-${stepId}`);
  if (!pillsList || !imgGrid) return;
  const images = Array.from(imgGrid.querySelectorAll('.draggable-img'));
  const mapping = new Map(); // substep index -> [image order]
  images.forEach(img => {
    const sub = img.getAttribute('data-substep-index');
    if (sub === null || sub === '') return;
    const orderNum = parseInt(img.getAttribute('data-order') || '0', 10) || 0;
    const key = String(parseInt(sub, 10));
    if (!mapping.has(key)) mapping.set(key, []);
    mapping.get(key).push(orderNum);
  });
  Array.from(pillsList.querySelectorAll('.draggable-pill')).forEach(pill => {
    const idx = pill.getAttribute('data-index');
    const holder = pill.querySelector('.linked-images');
    if (!holder) return;
    holder.innerHTML = '';
    const nums = (mapping.get(String(idx)) || []).sort((a,b)=>a-b);
    nums.forEach(n => {
      const badge = document.createElement('span');
      badge.className = 'inline-flex items-center justify-center w-5 h-5 rounded-full bg-purple-500 text-white text-[10px] font-bold shadow-sm';
      badge.textContent = n;
      holder.appendChild(badge);
    });
  });
}

function addPdfThumb(stepId, data){
  const container = document.getElementById('pdfs-'+stepId);
  const div = document.createElement('div');
  div.className = 'relative group';
  const ts = new Date();
  const pad = n => String(n).padStart(2,'0');
  const hours12 = (h)=>{ const hh = h % 12 || 12; return pad(hh); };
  const ampm = ts.getHours() >= 12 ? 'PM' : 'AM';
  const stamp = `${pad(ts.getMonth()+1)}${pad(ts.getDate())}${String(ts.getFullYear()).slice(-2)}-${hours12(ts.getHours())}${pad(ts.getMinutes())}${pad(ts.getSeconds())}${ampm}`;
  const baseName = (data.name || 'PDF');
  const parts = baseName.split('.');
  const ext = parts.length > 1 ? '.' + parts.pop() : '';
  const nameWithStamp = `${parts.join('.')} (${stamp})${ext}`;
  div.innerHTML = `<div class=\"rounded border w-full h-28 bg-base-300/30 flex items-center justify-center cursor-pointer pdf-thumb\" data-url=\"${data.url}\" data-name=\"${nameWithStamp}\" title=\"${nameWithStamp}\"><span class=\"text-xs\">Loading…</span></div><button class=\"btn btn-xs btn-error absolute top-1 right-1 opacity-0 group-hover:opacity-100 delete-pdf\" data-step=\"${stepId}\" data-id=\"${data.id}\">✕</button>`;
  container.appendChild(div);
  const thumb = div.querySelector('.pdf-thumb');
  renderPdfThumbnail(thumb);
}

// PDF upload button
document.querySelectorAll('[data-open-pdf-upload]').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    const stepId = btn.getAttribute('data-open-pdf-upload');
    const input = document.querySelector(`[data-upload-pdf-step="${stepId}"]`);
    input.click();
  });
});

document.querySelectorAll('[data-upload-pdf-step]').forEach(input=>{
  input.addEventListener('change', async ()=>{
    const stepId = input.getAttribute('data-upload-pdf-step');
    const file = input.files[0]; if (!file) return;
    const fd = new FormData(); fd.append('file', file);
    const res = await fetch(base + 'steps/' + stepId + '/files/upload/', {method:'POST', headers:{'X-CSRFToken': getCookie('csrftoken')}, body: fd});
    const data = await res.json(); if (data.ok) addPdfThumb(stepId, data);
    input.value = '';
  });
});

// PDF preview and delete
document.addEventListener('click', async (e)=>{
  const pdfDiv = e.target.closest('.pdf-thumb');
  if (pdfDiv) {
    const rawUrl = pdfDiv.getAttribute('data-url');
    // Build absolute same-origin URL
    let absUrl = rawUrl;
    try {
      absUrl = new URL(rawUrl, window.location.origin).href;
    } catch(_) {}
    // reuse image modal to show PDF via iframe
    const modal = document.getElementById('image-modal');
    const stage = document.getElementById('zoom-stage');
    stage.innerHTML = `
      <object data="${absUrl}#view=FitH" type="application/pdf" class="w-full h-full">
        <iframe src="${absUrl}#view=FitH" class="w-full h-full" style="border:0" allow="fullscreen"></iframe>
        <div class="w-full h-full flex items-center justify-center gap-3">
          <span class="text-sm opacity-70">Cannot preview PDF here.</span>
          <a href="${absUrl}" target="_blank" class="btn btn-sm">Open PDF</a>
        </div>
      </object>`;
    modal.showModal();
    return;
  }
  const delBtn = e.target.closest('.delete-pdf');
  if (delBtn) {
    e.preventDefault(); e.stopPropagation();
    const stepId = delBtn.getAttribute('data-step');
    const id = delBtn.getAttribute('data-id');
    await fetch(base + 'steps/' + stepId + '/files/' + id + '/delete/', {method:'POST', headers:{'X-CSRFToken': getCookie('csrftoken')}});
    delBtn.closest('.relative').remove();
  }
});

// Render a PDF thumbnail (first page) into the given .pdf-thumb element
async function renderPdfThumbnail(thumbEl){
  const fallbackToName = ()=>{
    const name = thumbEl.getAttribute('data-name') || thumbEl.getAttribute('title') || (thumbEl.getAttribute('data-url')||'').split('/').pop() || 'PDF';
    thumbEl.innerHTML = `<span class=\"text-xs truncate px-2\">${name}</span>`;
  };
  if (!thumbEl) return;
  if (!window['pdfjsLib']) { fallbackToName(); return; }
  let aborted = false;
  const timer = setTimeout(()=>{ if (!aborted) fallbackToName(); }, 4000);
  try {
    await new Promise(r=>requestAnimationFrame(()=>requestAnimationFrame(r)));
    let rawUrl = thumbEl.getAttribute('data-url');
    let absUrl = new URL(rawUrl, window.location.origin).href;
    const resp = await fetch(absUrl, { credentials: 'same-origin' });
    if (!resp.ok) throw new Error('Failed to fetch PDF');
    const buffer = await resp.arrayBuffer();
    const loadingTask = pdfjsLib.getDocument({ data: buffer });
    const pdf = await loadingTask.promise;
    const page = await pdf.getPage(1);
    const containerWidth = thumbEl.clientWidth || thumbEl.offsetWidth || 320;
    const containerHeight = thumbEl.clientHeight || thumbEl.offsetHeight || 112;
    const viewport = page.getViewport({ scale: 1 });
    const scale = Math.min(containerWidth / viewport.width, containerHeight / viewport.height) || 0.5;
    const scaledViewport = page.getViewport({ scale: Math.max(0.2, Math.min(2, scale)) });
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = Math.max(1, Math.floor(scaledViewport.width));
    canvas.height = Math.max(1, Math.floor(scaledViewport.height));
    await page.render({ canvasContext: ctx, viewport: scaledViewport }).promise;
    thumbEl.innerHTML = '';
    canvas.className = 'w-full h-full object-contain';
    thumbEl.appendChild(canvas);
    aborted = true; clearTimeout(timer);
  } catch(err){
    aborted = true; clearTimeout(timer); fallbackToName();
  }
}

// Render thumbnails for any existing PDF entries on load
document.addEventListener('DOMContentLoaded', ()=>{
  setTimeout(()=>{
    document.querySelectorAll('.pdf-thumb').forEach(el=>{
      // If server-rendered without data-name, synthesize timestamped name for display fallback
      if (!el.getAttribute('data-name')) {
        const orig = el.getAttribute('title') || (el.getAttribute('data-url')||'').split('/').pop() || 'Document.pdf';
        const ts = new Date();
        const pad = n=>String(n).padStart(2,'0');
        const hours12 = h=>{ const hh = h % 12 || 12; return pad(hh); };
        const ampm = ts.getHours() >= 12 ? 'PM' : 'AM';
        const stamp = `${pad(ts.getMonth()+1)}${pad(ts.getDate())}${String(ts.getFullYear()).slice(-2)}-${hours12(ts.getHours())}${pad(ts.getMinutes())}${pad(ts.getSeconds())}${ampm}`;
        const parts = orig.split('.'); const ext = parts.length>1?'.'+parts.pop():'';
        const withStamp = `${parts.join('.')} (${stamp})${ext}`;
        el.setAttribute('data-name', withStamp);
      }
      renderPdfThumbnail(el);
    });
  }, 50);
});

// Link creation modal
function openCreateLinkModal(initialUrl, onSave, initialTitle = ''){
  let modal = document.getElementById('create-link-modal');
  if (!modal) {
    modal = document.createElement('dialog');
    modal.id = 'create-link-modal';
    modal.className = 'modal';
    modal.innerHTML = `
      <div class="modal-box">
        <h3 class="font-bold text-lg mb-3">Create Link</h3>
        <div class="form-control mb-2">
          <label class="label"><span class="label-text">Button Label</span></label>
          <input id="new-link-title" class="input input-bordered" placeholder="Link label" />
        </div>
        <div class="form-control mb-4">
          <label class="label"><span class="label-text">URL</span></label>
          <input id="new-link-url" class="input input-bordered" placeholder="https://... or file://..." />
        </div>
        <div class="modal-action">
          <button id="create-link-cancel" class="btn btn-ghost">Cancel</button>
          <button id="create-link-save" class="btn btn-primary">Create</button>
        </div>
      </div>`;
    document.body.appendChild(modal);
  }
  modal.showModal();
  modal.querySelector('#new-link-title').value = initialTitle || '';
  modal.querySelector('#new-link-url').value = initialUrl || '';
  modal.querySelector('#create-link-cancel').onclick = ()=> modal.close();
  modal.querySelector('#create-link-save').onclick = ()=>{
    const title = modal.querySelector('#new-link-title').value.trim();
    const url = modal.querySelector('#new-link-url').value.trim();
    if (!title || (!/^https?:\/\//i.test(url) && !/^file:\/\//i.test(url))) { showToast('Provide label and valid URL', 'error'); return; }
    modal.close(); onSave && onSave({title, url});
  };
}

// Zoom & Pan for image modal
let currentScale = 1;
let offsetX = 0, offsetY = 0;
let isPanning = false, startX = 0, startY = 0;

let modalImgEl = document.getElementById('modal-image');
const zoomStage = document.getElementById('zoom-stage');

function applyTransform(){
  modalImgEl.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${currentScale})`;
  modalImgEl.style.transformOrigin = 'center center';
}

zoomStage.addEventListener('wheel', (e)=>{
  e.preventDefault();
  const delta = e.deltaY;
  const factor = delta > 0 ? 0.9 : 1.1;
  const prevScale = currentScale;
  currentScale = Math.min(10, Math.max(1, currentScale * factor));

  // Zoom towards cursor: adjust offset based on cursor position
  const rect = zoomStage.getBoundingClientRect();
  const cx = e.clientX - rect.left - rect.width/2;
  const cy = e.clientY - rect.top - rect.height/2;
  offsetX = (offsetX - cx) * (currentScale/prevScale) + cx;
  offsetY = (offsetY - cy) * (currentScale/prevScale) + cy;
  applyTransform();
}, { passive: false });

modalImgEl.addEventListener('mousedown', (e)=>{
  isPanning = true; startX = e.clientX - offsetX; startY = e.clientY - offsetY;
});
window.addEventListener('mousemove', (e)=>{
  if (!isPanning) return;
  offsetX = e.clientX - startX; offsetY = e.clientY - startY; applyTransform();
});
window.addEventListener('mouseup', ()=>{ isPanning = false; });

// Double click to reset
zoomStage.addEventListener('dblclick', ()=>{ currentScale = 1; offsetX = 0; offsetY = 0; applyTransform(); });

// Insert step before/after with event delegation (more reliable)
document.getElementById('steps').addEventListener('click', async (e)=>{
  const btn = e.target.closest('button[data-insert]');
  if (!btn) return;
  e.preventDefault();
  const card = btn.closest('.card');
  if (!card) return;
  const id = card.dataset.id;
  const dir = btn.getAttribute('data-insert');
  try {
    btn.disabled = true;
    const res = await fetch(base + 'steps/' + id + '/insert/' + dir + '/', {method:'POST', headers:{'X-CSRFToken': getCookie('csrftoken')}});
    const data = await res.json();
    if (data && data.ok) {
      location.reload();
    } else {
      btn.disabled = false;
    }
  } catch(err) {
    btn.disabled = false;
  }
});

// Auto-resize textareas
function autoResize(textarea) {
  textarea.style.height = 'auto';
  textarea.style.height = Math.max(textarea.scrollHeight, textarea.getAttribute('data-min-height') || 0) + 'px';
}

// Auto-resize all textareas on page load
document.addEventListener('DOMContentLoaded', function() {
  document.querySelectorAll('.auto-resize').forEach(textarea => {
    autoResize(textarea);
  });
});

// Initialize auto-resize for all textareas
document.addEventListener('DOMContentLoaded', function() {
  const textareas = document.querySelectorAll('.auto-resize');
  textareas.forEach(textarea => {
    initAutoResize(textarea);
  });
  
  // Watch for dynamically added textareas
  const observer = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      mutation.addedNodes.forEach((node) => {
        if (node.nodeType === 1) { // Element node
          // Check if the added node is a textarea
          if (node.classList && node.classList.contains('auto-resize')) {
            initAutoResize(node);
          }
          // Check for textareas within the added node
          const textareas = node.querySelectorAll && node.querySelectorAll('.auto-resize');
          if (textareas) {
            textareas.forEach(textarea => initAutoResize(textarea));
          }
        }
      });
    });
  });
  
  // Start observing
  observer.observe(document.body, {
    childList: true,
    subtree: true
  });
});

// Image drag and drop reordering
let draggedImg = null;

document.addEventListener('dragstart', (e) => {
  if (e.target.closest('.draggable-img')) {
    draggedImg = e.target.closest('.draggable-img');
    e.target.style.opacity = '0.5';
  }
});

document.addEventListener('dragend', (e) => {
  if (e.target.closest('.draggable-img')) {
    e.target.style.opacity = '';
    // Update image numbers immediately when drag ends
    if (draggedImg) {
      const container = draggedImg.parentElement;
      updateImageNumbers(container);
    }
    // Don't set draggedImg to null here - let drop event handle it
  }
});

document.addEventListener('dragover', (e) => {
  e.preventDefault();
  // Auto-scroll window while dragging images to reach off-screen pills
  if (draggedImg) {
    const edge = 60; // px from top/bottom
    if (e.clientY < edge) {
      window.scrollBy(0, -12);
    } else if (window.innerHeight - e.clientY < edge) {
      window.scrollBy(0, 12);
    }
  }
  const imgContainer = e.target.closest('.draggable-img');
  const pillContainer = e.target.closest('.draggable-pill');
  
  if (imgContainer && draggedImg && imgContainer !== draggedImg) {
    const container = imgContainer.parentElement;
    if (container && draggedImg) {
      const afterElement = getDragAfterElement(container, e.clientY);
      if (afterElement == null) {
        container.appendChild(draggedImg);
      } else {
        container.insertBefore(draggedImg, afterElement);
      }
    }
  } else if (pillContainer && draggedImg) {
    // Highlight the pill to show it's a valid drop target
    pillContainer.style.backgroundColor = 'rgba(59, 130, 246, 0.1)';
    pillContainer.style.borderColor = 'rgb(59, 130, 246)';
  }
});

document.addEventListener('dragleave', (e) => {
  const pillContainer = e.target.closest('.draggable-pill');
  if (pillContainer && draggedImg) {
    // Remove highlight when leaving pill
    pillContainer.style.backgroundColor = '';
    pillContainer.style.borderColor = '';
  }
});

document.addEventListener('drop', async (e) => {
  e.preventDefault();
  const pillContainer = e.target.closest('.draggable-pill');
  
  if (draggedImg && pillContainer) {
    // Remove highlight
    pillContainer.style.backgroundColor = '';
    pillContainer.style.borderColor = '';
    
    // Get the substep index from the pill
    const substepIndex = parseInt(pillContainer.getAttribute('data-index'));
    const stepId = pillContainer.closest('.step-card').dataset.id;
    const imgId = draggedImg.getAttribute('data-img-id');
    
    if (!isNaN(substepIndex) && stepId && imgId) {
      try {
        // Update the image's substep_index on the server
        const url = base + 'steps/' + stepId + '/images/' + imgId + '/update-substep/';
        console.log('Updating image substep:', url, 'substep_index:', substepIndex);
        const res = await fetch(url, {
          method: 'POST',
          headers: { 'X-CSRFToken': getCookie('csrftoken'), 'Content-Type': 'application/json' },
          body: JSON.stringify({ substep_index: substepIndex })
        });
        
        if (res.ok) {
          // Update the image's data attribute
          draggedImg.setAttribute('data-substep-index', substepIndex);
          showToast(`Image moved to substep ${substepIndex + 1}`, 'success');
          // Refresh bullet badges after assignment
          renderBulletImageBadges(stepId);
        } else {
          const errorData = await res.json().catch(() => ({ error: 'Unknown error' }));
          console.error('Server error:', res.status, errorData);
          showToast(`Failed to move image to substep: ${errorData.error || 'Unknown error'}`, 'error');
        }
      } catch (err) {
        console.error('Failed to update image substep:', err);
        showToast('Failed to move image to substep', 'error');
      }
    }
  } else if (draggedImg) {
    const container = draggedImg.parentElement;
    // Numbers and server update are handled in dragend event
    console.log('Image drop completed');
  }
  
  // Clear draggedImg after drop
  draggedImg = null;
});

function getDragAfterElement(container, y) {
  const draggableElements = [...container.querySelectorAll('.draggable-img:not(.dragging)')];
  return draggableElements.reduce((closest, child) => {
    const box = child.getBoundingClientRect();
    const offset = y - box.top - box.height / 2;
    if (offset < 0 && offset > closest.offset) {
      return { offset: offset, element: child };
    } else {
      return closest;
    }
  }, { offset: Number.NEGATIVE_INFINITY }).element;
}
</script>
<script>
// Reuse same modal helper as list page if absent
function showToast(message, type = 'success') {
  const toast = document.createElement('div');
  toast.className = 'toast toast-top toast-end';
  toast.style.position = 'fixed';
  toast.style.bottom = '0.75rem';
  toast.style.right = '0.75rem';
  toast.style.zIndex = '2147483647';
  toast.innerHTML = `<div class="alert alert-${type} max-w-[32rem] whitespace-pre-wrap break-words shadow-xl"><span>${message}</span></div>`;
  document.body.appendChild(toast);
  setTimeout(() => toast.remove(), type === 'error' ? 7000 : 3000);
}
function openCreateModuleModal({afterCreate}={}){
  let modal = document.getElementById('create-module-modal');
  if (!modal) {
    modal = document.createElement('dialog');
    modal.id = 'create-module-modal';
    modal.className = 'modal';
    modal.innerHTML = `
      <div class="modal-box">
        <h3 class="font-bold text-lg mb-3">Create Module</h3>
        <div class="form-control mb-2">
          <label class="label"><span class="label-text">Name</span></label>
          <input id="new-module-name" class="input input-bordered" placeholder="e.g., Engineering/Drafting" />
        </div>
        <div class="form-control mb-4">
          <label class="label"><span class="label-text">Description (optional)</span></label>
          <textarea id="new-module-desc" class="textarea textarea-bordered auto-resize" rows="3" placeholder="Short description"></textarea>
        </div>
        <div class="modal-action">
          <button id="create-module-cancel" class="btn btn-ghost">Cancel</button>
          <button id="create-module-save" class="btn btn-primary">Create</button>
        </div>
      </div>`;
    document.body.appendChild(modal);
  }
  modal.showModal();
  modal.querySelector('#create-module-cancel').onclick = ()=> modal.close();
  modal.querySelector('#create-module-save').onclick = async ()=>{
    const name = modal.querySelector('#new-module-name').value.trim();
    const description = modal.querySelector('#new-module-desc').value.trim();
    if (!name) { showToast('Module name is required', 'error'); return; }
    try {
      const res = await fetch('{% url "process_creator:module_create" %}', {
        method: 'POST', headers: {'X-CSRFToken': getCookie('csrftoken'), 'Content-Type': 'application/json'},
        body: JSON.stringify({name, description})
      });
      const data = await res.json();
      if (!res.ok || !data.ok) throw new Error(data.error || 'Failed to create module');
      modal.close();
      showToast('Module created', 'success');
      afterCreate && afterCreate({id: data.id, name: data.name});
    } catch(err) {
      console.error(err);
      showToast(err.message, 'error');
    }
  };
}

// Compact Mode Toggle
let isCompactMode = localStorage.getItem('compactMode') === 'true' || false;
let wasInCompactModeBeforeDrag = false;

// Initialize compact mode on page load
document.addEventListener('DOMContentLoaded', function() {
  if (isCompactMode) {
    toggleCompactMode(true);
    document.getElementById('compact-mode-toggle').innerHTML = '<i class="fas fa-expand-alt mr-1"></i>Normal Mode';
  }
  
  // Auto-resize all textareas on page load
  document.querySelectorAll('.step-details').forEach(textarea => {
    textarea.style.height = 'auto';
    textarea.style.height = textarea.scrollHeight + 'px';
  });
  
  // Initialize step navigation
  initializeStepNavigation();
  
  // Check if we need to scroll to a new step
  if (sessionStorage.getItem('scrollToNewStep') === 'true') {
    sessionStorage.removeItem('scrollToNewStep');
    
    // Wait a bit for everything to load, then scroll to the last step
    setTimeout(() => {
      const steps = document.querySelectorAll('#steps .step-card');
      const lastStep = steps[steps.length - 1];
      if (lastStep) {
        // Scroll to the new step
        lastStep.scrollIntoView({ 
          behavior: 'smooth', 
          block: 'center' 
        });
        
        // Focus the title input after scrolling
        setTimeout(() => {
          const titleInput = lastStep.querySelector('.step-title');
          if (titleInput) {
            titleInput.focus();
            titleInput.select(); // Select all text for easy editing
          }
        }, 500);
      }
    }, 200);
  }
});

document.getElementById('compact-mode-toggle').addEventListener('click', function() {
  isCompactMode = !isCompactMode;
  localStorage.setItem('compactMode', isCompactMode);
  toggleCompactMode(isCompactMode);
  this.innerHTML = isCompactMode ? 
    '<i class="fas fa-expand-alt mr-1"></i>Normal Mode' : 
    '<i class="fas fa-compress-alt mr-1"></i>Compact Mode';
});

function toggleCompactMode(compact) {
  const stepCards = document.querySelectorAll('.step-card');
  stepCards.forEach(card => {
    if (compact) {
      card.classList.add('step-compact');
    } else {
      card.classList.remove('step-compact');
    }
  });
}

// Step Navigation Functions
function initializeStepNavigation() {
  const stepNav = document.getElementById('step-nav');
  const steps = document.querySelectorAll('#steps .step-card');
  
  if (steps.length === 0) {
    stepNav.classList.add('hidden');
    return;
  }
  
  // Show navigation
  stepNav.classList.remove('hidden');
  
  // Create circles for each step
  const circlesContainer = stepNav.querySelector('.step-nav-circles');
  circlesContainer.innerHTML = '';
  
  steps.forEach((step, index) => {
    // Create navigation item container
    const navItem = document.createElement('div');
    navItem.className = 'step-nav-item';
    navItem.dataset.stepId = step.dataset.id;
    navItem.dataset.stepIndex = index;
    
    // Create circle
    const circle = document.createElement('div');
    circle.className = 'step-nav-circle';
    circle.textContent = index + 1;
    
    // Create title
    const title = document.createElement('div');
    title.className = 'step-nav-title';
    const stepTitle = step.querySelector('.step-title');
    title.textContent = stepTitle ? stepTitle.value || stepTitle.textContent : `Step ${index + 1}`;
    // Always set a tooltip with the full title
    navItem.title = title.textContent;
    
    // Assemble the item
    navItem.appendChild(circle);
    navItem.appendChild(title);
    
    // Click to scroll to step
    navItem.addEventListener('click', () => {
      scrollToStep(step);
    });
    
    circlesContainer.appendChild(navItem);
  });
  
  // Adjust spacing based on number of steps
  adjustNavigationSpacing(steps.length);
  
  // Set up scroll spy to highlight active step
  setupScrollSpy();
  
  // Set up smart viewport for many steps
  setupSmartViewport();
  
  // Add scroll event listener as backup
  setupScrollListener();
}

function adjustNavigationSpacing(stepCount) {
  const circlesContainer = document.querySelector('.step-nav-circles');
  const navItems = circlesContainer.querySelectorAll('.step-nav-item');
  
  // Much closer spacing to fit more steps
  let gap = 0;
  if (stepCount <= 5) gap = 8;
  else if (stepCount <= 10) gap = 6;
  else if (stepCount <= 15) gap = 4;
  else gap = 2;
  
  navItems.forEach((item, index) => {
    item.style.marginBottom = `${gap}px`;
  });
}

function scrollToStep(stepElement) {
  try {
    const header = document.querySelector('.sticky.top-0');
    const headerHeight = header ? header.offsetHeight : 0;
    const rect = stepElement.getBoundingClientRect();
    const targetTop = window.pageYOffset + rect.top - Math.max(0, headerHeight + 8);
    window.scrollTo({ top: targetTop, behavior: 'smooth' });
  } catch(_) {
    stepElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
  }
}

function setupScrollSpy() {
  const steps = document.querySelectorAll('#steps .step-card');
  const navItems = document.querySelectorAll('.step-nav-item');
  
  // Create intersection observer with more sensitive settings
  const observer = new IntersectionObserver((entries) => {
    // Find the step that's most visible (highest intersection ratio)
    let mostVisible = null;
    let highestRatio = 0;
    
    entries.forEach(entry => {
      if (entry.isIntersecting && entry.intersectionRatio > highestRatio) {
        highestRatio = entry.intersectionRatio;
        mostVisible = entry.target;
      }
    });
    
    // If we have a most visible step, update the navigation
    if (mostVisible) {
      const stepId = mostVisible.dataset.id;
      const navItem = document.querySelector(`.step-nav-item[data-step-id="${stepId}"]`);
      
      // Remove active class from all nav items
      navItems.forEach(item => {
        item.classList.remove('active');
        item.querySelector('.step-nav-circle').classList.remove('active');
      });
      
      // Add active class to current nav item
      if (navItem) {
        navItem.classList.add('active');
        navItem.querySelector('.step-nav-circle').classList.add('active');
        
        // Update smart viewport to show this step
        const activeIndex = parseInt(navItem.dataset.stepIndex);
        const screenHeight = window.innerHeight;
        const availableHeight = screenHeight - 120;
        const itemHeight = 40;
        const maxVisible = Math.floor(availableHeight / itemHeight);
        const startIndex = Math.max(0, activeIndex - Math.floor(maxVisible / 2));
        const endIndex = Math.min(navItems.length - 1, startIndex + maxVisible - 1);
        showStepsInRange(startIndex, endIndex);
      }
    }
  }, {
    threshold: [0.1, 0.3, 0.5, 0.7, 0.9], // Multiple thresholds for better detection
    rootMargin: '-10% 0px -10% 0px' // Smaller margin for more responsive detection
  });
  
  // Observe all steps
  steps.forEach(step => observer.observe(step));
}

// Update navigation when steps are reordered
function updateStepNavigation() {
  initializeStepNavigation();
}

// Update navigation title when step title changes
function updateNavigationTitle(stepId, newTitle) {
  const navItem = document.querySelector(`.step-nav-item[data-step-id="${stepId}"]`);
  if (navItem) {
    const titleElement = navItem.querySelector('.step-nav-title');
    if (titleElement) {
      titleElement.textContent = newTitle;
    }
  }
}

// Smart viewport - show only relevant steps around current one
function setupSmartViewport() {
  const navItems = document.querySelectorAll('.step-nav-item');
  
  // Calculate max visible based on screen height
  const screenHeight = window.innerHeight;
  const availableHeight = screenHeight - 120; // Account for padding
  const itemHeight = 40; // Approximate height of each nav item
  const maxVisible = Math.floor(availableHeight / itemHeight);
  
  if (navItems.length <= maxVisible) {
    // Show all if we have few steps
    navItems.forEach(item => item.style.display = 'flex');
    return;
  }
  
  // Initially show first few steps
  showStepsInRange(0, maxVisible - 1);
  
  // Update viewport when active step changes
  const observer = new MutationObserver(() => {
    const activeItem = document.querySelector('.step-nav-item.active');
    if (activeItem) {
      const activeIndex = parseInt(activeItem.dataset.stepIndex);
      const startIndex = Math.max(0, activeIndex - Math.floor(maxVisible / 2));
      const endIndex = Math.min(navItems.length - 1, startIndex + maxVisible - 1);
      showStepsInRange(startIndex, endIndex);
    }
  });
  
  // Watch for active class changes
  navItems.forEach(item => {
    observer.observe(item, { attributes: true, attributeFilter: ['class'] });
  });
}

function showStepsInRange(startIndex, endIndex) {
  const navItems = document.querySelectorAll('.step-nav-item');
  navItems.forEach((item, index) => {
    if (index >= startIndex && index <= endIndex) {
      item.style.display = 'flex';
      item.style.opacity = '0';
      item.style.transform = 'translateX(-5px)';
      // Very gentle fade in
      setTimeout(() => {
        item.style.transition = 'all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
        item.style.opacity = '1';
        item.style.transform = 'translateX(0)';
      }, 20);
    } else {
      // Very gentle fade out
      item.style.transition = 'all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
      item.style.opacity = '0';
      item.style.transform = 'translateX(-5px)';
      setTimeout(() => {
        item.style.display = 'none';
      }, 600);
    }
  });
}

// Scroll listener as backup for scroll spy
function setupScrollListener() {
  let scrollTimeout;
  
  window.addEventListener('scroll', () => {
    // Throttle scroll events
    clearTimeout(scrollTimeout);
    scrollTimeout = setTimeout(() => {
      const steps = document.querySelectorAll('#steps .step-card');
      const navItems = document.querySelectorAll('.step-nav-item');
      
      let closestStep = null;
      let closestDistance = Infinity;
      
      // Find the step closest to the center of the viewport
      steps.forEach(step => {
        const rect = step.getBoundingClientRect();
        const viewportCenter = window.innerHeight / 2;
        const stepCenter = rect.top + (rect.height / 2);
        const distance = Math.abs(stepCenter - viewportCenter);
        
        if (distance < closestDistance) {
          closestDistance = distance;
          closestStep = step;
        }
      });
      
      // Update navigation if we found a closest step
      if (closestStep) {
        const stepId = closestStep.dataset.id;
        const navItem = document.querySelector(`.step-nav-item[data-step-id="${stepId}"]`);
        
        if (navItem && !navItem.classList.contains('active')) {
          // Remove active class from all nav items
          navItems.forEach(item => {
            item.classList.remove('active');
            item.querySelector('.step-nav-circle').classList.remove('active');
          });
          
          // Add active class to current nav item
          navItem.classList.add('active');
          navItem.querySelector('.step-nav-circle').classList.add('active');
          
          // Update smart viewport
          const activeIndex = parseInt(navItem.dataset.stepIndex);
          const screenHeight = window.innerHeight;
          const availableHeight = screenHeight - 120;
          const itemHeight = 40;
          const maxVisible = Math.floor(availableHeight / itemHeight);
          const startIndex = Math.max(0, activeIndex - Math.floor(maxVisible / 2));
          const endIndex = Math.min(navItems.length - 1, startIndex + maxVisible - 1);
          showStepsInRange(startIndex, endIndex);
        }
      }
    }, 50); // 50ms throttle
  });
}

// Auto-compact mode during dragging - REMOVED
// Users can manually toggle compact mode if needed for reordering

// Focus This Only — show only one step, hide all else
let focusedStepId = null;

function enterFocusMode(stepId) {
  focusedStepId = String(stepId);
  // Hide non-focused step cards
  document.querySelectorAll('#steps .step-card').forEach(card => {
    if (card.dataset.id !== String(stepId)) {
      card.style.display = 'none';
    } else {
      card.style.display = '';
      // Scroll focused step into view gently
      setTimeout(() => card.scrollIntoView({ behavior: 'smooth', block: 'center' }), 50);
    }
  });
  // Hide process-level sections
  ['summary-section','description-section','notes-section','analysis-section'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.style.display = 'none';
  });
  // Show floating exit button (create if needed)
  let exitBtn = document.getElementById('exit-focus-btn');
  if (!exitBtn) {
    exitBtn = document.createElement('button');
    exitBtn.id = 'exit-focus-btn';
    exitBtn.className = 'btn btn-outline btn-sm fixed top-3 right-3 z-50';
    exitBtn.textContent = 'Exit Focus';
    exitBtn.addEventListener('click', exitFocusMode);
    document.body.appendChild(exitBtn);
  } else {
    exitBtn.style.display = '';
  }
  // Update button labels
  document.querySelectorAll('#steps .focus-step').forEach(b => b.textContent = 'Focus This Only');
  const activeBtn = document.querySelector(`#steps .focus-step[data-step="${CSS.escape(String(stepId))}"]`);
  if (activeBtn) activeBtn.textContent = 'Unfocus';
}

function exitFocusMode() {
  focusedStepId = null;
  // Show all step cards
  document.querySelectorAll('#steps .step-card').forEach(card => {
    card.style.display = '';
  });
  // Re-apply all current toggle states after layout is restored
  const applyAllVisibility = () => {
    try { applySummaryVisibility && applySummaryVisibility(); } catch(_) {}
    try { applyDescriptionVisibility && applyDescriptionVisibility(); } catch(_) {}
    try { applyNotesVisibility && applyNotesVisibility(); } catch(_) {}
    try { applyAnalysisVisibility && applyAnalysisVisibility(); } catch(_) {}
    try { applyAttachmentVisibility && applyAttachmentVisibility(); } catch(_) {}
  };
  // Apply immediately and again on next tick to avoid any intermediate flashes
  applyAllVisibility();
  setTimeout(applyAllVisibility, 50);
  // Hide exit button if present
  const exitBtn = document.getElementById('exit-focus-btn');
  if (exitBtn) exitBtn.style.display = 'none';
  // Reset button labels
  document.querySelectorAll('#steps .focus-step').forEach(b => b.textContent = 'Focus This Only');
}

// Wire up per-step Focus button (event delegation)
document.getElementById('steps').addEventListener('click', (e) => {
  const btn = e.target.closest('.focus-step');
  if (!btn) return;
  e.preventDefault();
  const stepId = btn.getAttribute('data-step');
  if (!stepId) return;
  if (focusedStepId && String(stepId) === String(focusedStepId)) {
    exitFocusMode();
  } else {
    enterFocusMode(stepId);
  }
});
</script>
{% endblock %}


